{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.fetchRetry = factory());\n})(this, function () {\n  'use strict';\n\n  var fetchRetry = function (fetch, defaults) {\n    defaults = defaults || {};\n    if (typeof fetch !== 'function') {\n      throw new ArgumentError('fetch must be a function');\n    }\n    if (typeof defaults !== 'object') {\n      throw new ArgumentError('defaults must be an object');\n    }\n    if (defaults.retries !== undefined && !isPositiveInteger(defaults.retries)) {\n      throw new ArgumentError('retries must be a positive integer');\n    }\n    if (defaults.retryDelay !== undefined && !isPositiveInteger(defaults.retryDelay) && typeof defaults.retryDelay !== 'function') {\n      throw new ArgumentError('retryDelay must be a positive integer or a function returning a positive integer');\n    }\n    if (defaults.retryOn !== undefined && !Array.isArray(defaults.retryOn) && typeof defaults.retryOn !== 'function') {\n      throw new ArgumentError('retryOn property expects an array or function');\n    }\n    var baseDefaults = {\n      retries: 3,\n      retryDelay: 1000,\n      retryOn: []\n    };\n    defaults = Object.assign(baseDefaults, defaults);\n    return function fetchRetry(input, init) {\n      var retries = defaults.retries;\n      var retryDelay = defaults.retryDelay;\n      var retryOn = defaults.retryOn;\n      if (init && init.retries !== undefined) {\n        if (isPositiveInteger(init.retries)) {\n          retries = init.retries;\n        } else {\n          throw new ArgumentError('retries must be a positive integer');\n        }\n      }\n      if (init && init.retryDelay !== undefined) {\n        if (isPositiveInteger(init.retryDelay) || typeof init.retryDelay === 'function') {\n          retryDelay = init.retryDelay;\n        } else {\n          throw new ArgumentError('retryDelay must be a positive integer or a function returning a positive integer');\n        }\n      }\n      if (init && init.retryOn) {\n        if (Array.isArray(init.retryOn) || typeof init.retryOn === 'function') {\n          retryOn = init.retryOn;\n        } else {\n          throw new ArgumentError('retryOn property expects an array or function');\n        }\n      }\n\n      // eslint-disable-next-line no-undef\n      return new Promise(function (resolve, reject) {\n        var wrappedFetch = function (attempt) {\n          // As of node 18, this is no longer needed since node comes with native support for fetch:\n          /* istanbul ignore next */\n          var _input = typeof Request !== 'undefined' && input instanceof Request ? input.clone() : input;\n          fetch(_input, init).then(function (response) {\n            if (Array.isArray(retryOn) && retryOn.indexOf(response.status) === -1) {\n              resolve(response);\n            } else if (typeof retryOn === 'function') {\n              try {\n                // eslint-disable-next-line no-undef\n                return Promise.resolve(retryOn(attempt, null, response)).then(function (retryOnResponse) {\n                  if (retryOnResponse) {\n                    retry(attempt, null, response);\n                  } else {\n                    resolve(response);\n                  }\n                }).catch(reject);\n              } catch (error) {\n                reject(error);\n              }\n            } else {\n              if (attempt < retries) {\n                retry(attempt, null, response);\n              } else {\n                resolve(response);\n              }\n            }\n          }).catch(function (error) {\n            if (typeof retryOn === 'function') {\n              try {\n                // eslint-disable-next-line no-undef\n                Promise.resolve(retryOn(attempt, error, null)).then(function (retryOnResponse) {\n                  if (retryOnResponse) {\n                    retry(attempt, error, null);\n                  } else {\n                    reject(error);\n                  }\n                }).catch(function (error) {\n                  reject(error);\n                });\n              } catch (error) {\n                reject(error);\n              }\n            } else if (attempt < retries) {\n              retry(attempt, error, null);\n            } else {\n              reject(error);\n            }\n          });\n        };\n        function retry(attempt, error, response) {\n          var delay = typeof retryDelay === 'function' ? retryDelay(attempt, error, response) : retryDelay;\n          setTimeout(function () {\n            wrappedFetch(++attempt);\n          }, delay);\n        }\n        wrappedFetch(0);\n      });\n    };\n  };\n  function isPositiveInteger(value) {\n    return Number.isInteger(value) && value >= 0;\n  }\n  function ArgumentError(message) {\n    this.name = 'ArgumentError';\n    this.message = message;\n  }\n  return fetchRetry;\n});","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}