{"ast":null,"code":"import _asyncToGenerator from \"D:/Scripts/Factory/fhevm-sdk-pro/node_modules/.pnpm/@babel+runtime@7.26.10/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { JsonRpcProvider, BrowserProvider, Contract, getAddress as getAddress$2, ethers, isAddress, AbiCoder } from 'ethers';\nimport createHash from 'keccak';\nimport fetchRetry from 'fetch-retry';\nimport { threads } from 'wasm-feature-detect';\nvar global$1 = typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {};\n\n/*\r\n * Copyright 2022 Google Inc. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n// Note: we use `wasm_bindgen_worker_`-prefixed message types to make sure\n// we can handle bundling into other files, which might happen to have their\n// own `postMessage`/`onmessage` communication channels.\n//\n// If we didn't take that into the account, we could send much simpler signals\n// like just `0` or whatever, but the code would be less resilient.\n\nfunction waitForMsgType(target, type) {\n  return new Promise(resolve => {\n    target.addEventListener('message', function onMsg({\n      data\n    }) {\n      if (data?.type !== type) return;\n      target.removeEventListener('message', onMsg);\n      resolve(data);\n    });\n  });\n}\nwaitForMsgType(self, 'wasm_bindgen_worker_init').then(/*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* ({\n    init,\n    receiver\n  }) {\n    // # Note 1\n    // Our JS should have been generated in\n    // `[out-dir]/snippets/wasm-bindgen-rayon-[hash]/workerHelpers.js`,\n    // resolve the main module via `../../..`.\n    //\n    // This might need updating if the generated structure changes on wasm-bindgen\n    // side ever in the future, but works well with bundlers today. The whole\n    // point of this crate, after all, is to abstract away unstable features\n    // and temporary bugs so that you don't need to deal with them in your code.\n    //\n    // # Note 2\n    // This could be a regular import, but then some bundlers complain about\n    // circular deps.\n    //\n    // Dynamic import could be cheap if this file was inlined into the parent,\n    // which would require us just using `../../..` in `new Worker` below,\n    // but that doesn't work because wasm-pack unconditionally adds\n    // \"sideEffects\":false (see below).\n    //\n    // OTOH, even though it can't be inlined, it should be still reasonably\n    // cheap since the requested file is already in cache (it was loaded by\n    // the main thread).\n    const pkg = yield Promise.resolve().then(function () {\n      return tfhe;\n    });\n    yield pkg.default(init);\n    postMessage({\n      type: 'wasm_bindgen_worker_ready'\n    });\n    pkg.wbg_rayon_start_worker(receiver);\n  });\n  return function (_x) {\n    return _ref.apply(this, arguments);\n  };\n}());\nfunction startWorkers(_x2, _x3, _x4) {\n  return _startWorkers.apply(this, arguments);\n}\nfunction _startWorkers() {\n  _startWorkers = _asyncToGenerator(function* (module, memory, builder) {\n    if (builder.numThreads() === 0) {\n      throw new Error(`num_threads must be > 0.`);\n    }\n    const workerInit = {\n      type: 'wasm_bindgen_worker_init',\n      init: {\n        module_or_path: module,\n        memory\n      },\n      receiver: builder.receiver()\n    };\n    yield Promise.all(Array.from({\n      length: builder.numThreads()\n    }, /*#__PURE__*/_asyncToGenerator(function* () {\n      // Self-spawn into a new Worker.\n      //\n      // TODO: while `new URL('...', import.meta.url) becomes a semi-standard\n      // way to get asset URLs relative to the module across various bundlers\n      // and browser, ideally we should switch to `import.meta.resolve`\n      // once it becomes a standard.\n      //\n      // Note: we could use `../../..` as the URL here to inline workerHelpers.js\n      // into the parent entry instead of creating another split point -\n      // this would be preferable from optimization perspective -\n      // however, Webpack then eliminates all message handler code\n      // because wasm-pack produces \"sideEffects\":false in package.json\n      // unconditionally.\n      //\n      // The only way to work around that is to have side effect code\n      // in an entry point such as Worker file itself.\n      const worker = new Worker(new URL('./workerHelpers.js', import.meta.url), {\n        type: 'module'\n      });\n      worker.postMessage(workerInit);\n      yield waitForMsgType(worker, 'wasm_bindgen_worker_ready');\n      return worker;\n    })));\n    builder.build();\n  });\n  return _startWorkers.apply(this, arguments);\n}\nlet wasm$1;\nfunction addToExternrefTable0$1(obj) {\n  const idx = wasm$1.__externref_table_alloc();\n  wasm$1.__wbindgen_export_2.set(idx, obj);\n  return idx;\n}\nfunction handleError$1(f, args) {\n  try {\n    return f.apply(this, args);\n  } catch (e) {\n    const idx = addToExternrefTable0$1(e);\n    wasm$1.__wbindgen_exn_store(idx);\n  }\n}\nconst cachedTextDecoder$1 = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-8', {\n  ignoreBOM: true,\n  fatal: true\n}) : {\n  decode: () => {\n    throw Error('TextDecoder not available');\n  }\n};\nif (typeof TextDecoder !== 'undefined') {\n  cachedTextDecoder$1.decode();\n}\nlet cachedUint8ArrayMemory0$1 = null;\nfunction getUint8ArrayMemory0$1() {\n  if (cachedUint8ArrayMemory0$1 === null || cachedUint8ArrayMemory0$1.buffer !== wasm$1.memory.buffer) {\n    cachedUint8ArrayMemory0$1 = new Uint8Array(wasm$1.memory.buffer);\n  }\n  return cachedUint8ArrayMemory0$1;\n}\nfunction getStringFromWasm0$1(ptr, len) {\n  ptr = ptr >>> 0;\n  return cachedTextDecoder$1.decode(getUint8ArrayMemory0$1().slice(ptr, ptr + len));\n}\nlet WASM_VECTOR_LEN$1 = 0;\nconst cachedTextEncoder$1 = typeof TextEncoder !== 'undefined' ? new TextEncoder('utf-8') : {\n  encode: () => {\n    throw Error('TextEncoder not available');\n  }\n};\nconst encodeString$1 = function (arg, view) {\n  const buf = cachedTextEncoder$1.encode(arg);\n  view.set(buf);\n  return {\n    read: arg.length,\n    written: buf.length\n  };\n};\nfunction passStringToWasm0$1(arg, malloc, realloc) {\n  if (realloc === undefined) {\n    const buf = cachedTextEncoder$1.encode(arg);\n    const ptr = malloc(buf.length, 1) >>> 0;\n    getUint8ArrayMemory0$1().subarray(ptr, ptr + buf.length).set(buf);\n    WASM_VECTOR_LEN$1 = buf.length;\n    return ptr;\n  }\n  let len = arg.length;\n  let ptr = malloc(len, 1) >>> 0;\n  const mem = getUint8ArrayMemory0$1();\n  let offset = 0;\n  for (; offset < len; offset++) {\n    const code = arg.charCodeAt(offset);\n    if (code > 0x7F) break;\n    mem[ptr + offset] = code;\n  }\n  if (offset !== len) {\n    if (offset !== 0) {\n      arg = arg.slice(offset);\n    }\n    ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;\n    const view = getUint8ArrayMemory0$1().subarray(ptr + offset, ptr + len);\n    const ret = encodeString$1(arg, view);\n    offset += ret.written;\n    ptr = realloc(ptr, len, offset, 1) >>> 0;\n  }\n  WASM_VECTOR_LEN$1 = offset;\n  return ptr;\n}\nlet cachedDataViewMemory0$1 = null;\nfunction getDataViewMemory0$1() {\n  if (cachedDataViewMemory0$1 === null || cachedDataViewMemory0$1.buffer !== wasm$1.memory.buffer) {\n    cachedDataViewMemory0$1 = new DataView(wasm$1.memory.buffer);\n  }\n  return cachedDataViewMemory0$1;\n}\nfunction isLikeNone$1(x) {\n  return x === undefined || x === null;\n}\nfunction debugString$1(val) {\n  // primitive types\n  const type = typeof val;\n  if (type == 'number' || type == 'boolean' || val == null) {\n    return `${val}`;\n  }\n  if (type == 'string') {\n    return `\"${val}\"`;\n  }\n  if (type == 'symbol') {\n    const description = val.description;\n    if (description == null) {\n      return 'Symbol';\n    } else {\n      return `Symbol(${description})`;\n    }\n  }\n  if (type == 'function') {\n    const name = val.name;\n    if (typeof name == 'string' && name.length > 0) {\n      return `Function(${name})`;\n    } else {\n      return 'Function';\n    }\n  }\n  // objects\n  if (Array.isArray(val)) {\n    const length = val.length;\n    let debug = '[';\n    if (length > 0) {\n      debug += debugString$1(val[0]);\n    }\n    for (let i = 1; i < length; i++) {\n      debug += ', ' + debugString$1(val[i]);\n    }\n    debug += ']';\n    return debug;\n  }\n  // Test for built-in\n  const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val));\n  let className;\n  if (builtInMatches && builtInMatches.length > 1) {\n    className = builtInMatches[1];\n  } else {\n    // Failed to match the standard '[object ClassName]'\n    return toString.call(val);\n  }\n  if (className == 'Object') {\n    // we're a user defined class or Object\n    // JSON.stringify avoids problems with cycles, and is generally much\n    // easier than looping through ownProperties of `val`.\n    try {\n      return 'Object(' + JSON.stringify(val) + ')';\n    } catch (_) {\n      return 'Object';\n    }\n  }\n  // errors\n  if (val instanceof Error) {\n    return `${val.name}: ${val.message}\\n${val.stack}`;\n  }\n  // TODO we could test for more things here, like `Set`s and `Map`s.\n  return className;\n}\nfunction _assertClass$1(instance, klass) {\n  if (!(instance instanceof klass)) {\n    throw new Error(`expected instance of ${klass.name}`);\n  }\n}\nfunction takeFromExternrefTable0$1(idx) {\n  const value = wasm$1.__wbindgen_export_2.get(idx);\n  wasm$1.__externref_table_dealloc(idx);\n  return value;\n}\nfunction getArrayU8FromWasm0$1(ptr, len) {\n  ptr = ptr >>> 0;\n  return getUint8ArrayMemory0$1().subarray(ptr / 1, ptr / 1 + len);\n}\nfunction passArray8ToWasm0$1(arg, malloc) {\n  const ptr = malloc(arg.length * 1, 1) >>> 0;\n  getUint8ArrayMemory0$1().set(arg, ptr / 1);\n  WASM_VECTOR_LEN$1 = arg.length;\n  return ptr;\n}\nfunction init_panic_hook() {\n  wasm$1.init_panic_hook();\n}\n\n/**\n * @param {number} num_threads\n * @returns {Promise<any>}\n */\nfunction initThreadPool(num_threads) {\n  const ret = wasm$1.initThreadPool(num_threads);\n  return ret;\n}\n\n/**\n * @param {number} receiver\n */\nfunction wbg_rayon_start_worker(receiver) {\n  wasm$1.wbg_rayon_start_worker(receiver);\n}\n/**\n * @enum {0 | 1}\n */\nconst ZkComputeLoad = Object.freeze({\n  Proof: 0,\n  \"0\": \"Proof\",\n  Verify: 1,\n  \"1\": \"Verify\"\n});\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_boolean_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_booleanciphertext_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_booleanclientkey_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_booleancompressedciphertext_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_booleancompressedserverkey_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_booleannoisedistribution_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_booleanparameters_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_booleanpublickey_free(ptr >>> 0, 1));\nconst CompactCiphertextListFinalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_compactciphertextlist_free(ptr >>> 0, 1));\nclass CompactCiphertextList {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(CompactCiphertextList.prototype);\n    obj.__wbg_ptr = ptr;\n    CompactCiphertextListFinalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    CompactCiphertextListFinalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_compactciphertextlist_free(ptr, 0);\n  }\n  /**\n   * @param {TfheCompactPublicKey} public_key\n   * @returns {CompactCiphertextListBuilder}\n   */\n  static builder(public_key) {\n    _assertClass$1(public_key, TfheCompactPublicKey);\n    const ret = wasm$1.compactciphertextlist_builder(public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return CompactCiphertextListBuilder.__wrap(ret[0]);\n  }\n  /**\n   * @returns {number}\n   */\n  len() {\n    const ret = wasm$1.compactciphertextlist_len(this.__wbg_ptr);\n    return ret >>> 0;\n  }\n  /**\n   * @returns {boolean}\n   */\n  is_empty() {\n    const ret = wasm$1.compactciphertextlist_is_empty(this.__wbg_ptr);\n    return ret !== 0;\n  }\n  /**\n   * @param {number} index\n   * @returns {FheTypes | undefined}\n   */\n  get_kind_of(index) {\n    const ret = wasm$1.compactciphertextlist_get_kind_of(this.__wbg_ptr, index);\n    return ret === 84 ? undefined : ret;\n  }\n  /**\n   * @returns {CompactCiphertextListExpander}\n   */\n  expand() {\n    const ret = wasm$1.compactciphertextlist_expand(this.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return CompactCiphertextListExpander.__wrap(ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.compactciphertextlist_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {CompactCiphertextList}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.compactciphertextlist_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return CompactCiphertextList.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.compactciphertextlist_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {CompactCiphertextList}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.compactciphertextlist_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return CompactCiphertextList.__wrap(ret[0]);\n  }\n}\nconst CompactCiphertextListBuilderFinalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_compactciphertextlistbuilder_free(ptr >>> 0, 1));\nclass CompactCiphertextListBuilder {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(CompactCiphertextListBuilder.prototype);\n    obj.__wbg_ptr = ptr;\n    CompactCiphertextListBuilderFinalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    CompactCiphertextListBuilderFinalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_compactciphertextlistbuilder_free(ptr, 0);\n  }\n  /**\n   * @param {number} value\n   */\n  push_u24(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_u24(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {bigint} value\n   */\n  push_u40(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_u40(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {bigint} value\n   */\n  push_u48(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_u48(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {bigint} value\n   */\n  push_u56(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_u56(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {number} value\n   */\n  push_u2(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_u2(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {number} value\n   */\n  push_u4(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_u4(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {number} value\n   */\n  push_u6(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_u6(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {number} value\n   */\n  push_u8(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_u8(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {number} value\n   */\n  push_u10(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_u10(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {number} value\n   */\n  push_u12(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_u12(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {number} value\n   */\n  push_u14(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_u14(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {number} value\n   */\n  push_u16(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_u16(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {number} value\n   */\n  push_u32(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_u32(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {bigint} value\n   */\n  push_u64(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_u64(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {number} value\n   */\n  push_i24(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_i24(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {bigint} value\n   */\n  push_i40(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_i40(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {bigint} value\n   */\n  push_i48(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_i48(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {bigint} value\n   */\n  push_i56(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_i56(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {number} value\n   */\n  push_i2(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_i2(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {number} value\n   */\n  push_i4(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_i4(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {number} value\n   */\n  push_i6(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_i6(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {number} value\n   */\n  push_i8(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_i8(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {number} value\n   */\n  push_i10(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_i10(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {number} value\n   */\n  push_i12(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_i12(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {number} value\n   */\n  push_i14(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_i14(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {number} value\n   */\n  push_i16(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_i16(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {number} value\n   */\n  push_i32(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_i32(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {bigint} value\n   */\n  push_i64(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_i64(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {any} value\n   */\n  push_u128(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_u128(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {any} value\n   */\n  push_u160(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_u160(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {any} value\n   */\n  push_u256(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_u256(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {any} value\n   */\n  push_u512(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_u512(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {any} value\n   */\n  push_u1024(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_u1024(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {any} value\n   */\n  push_u2048(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_u2048(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {any} value\n   */\n  push_i128(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_i128(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {any} value\n   */\n  push_i160(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_i160(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {any} value\n   */\n  push_i256(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_i256(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {any} value\n   */\n  push_i512(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_i512(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {any} value\n   */\n  push_i1024(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_i1024(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {any} value\n   */\n  push_i2048(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_i2048(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {boolean} value\n   */\n  push_boolean(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_boolean(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @returns {CompactCiphertextList}\n   */\n  build() {\n    const ret = wasm$1.compactciphertextlistbuilder_build(this.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return CompactCiphertextList.__wrap(ret[0]);\n  }\n  /**\n   * @returns {CompactCiphertextList}\n   */\n  build_packed() {\n    const ret = wasm$1.compactciphertextlistbuilder_build_packed(this.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return CompactCiphertextList.__wrap(ret[0]);\n  }\n  /**\n   * @param {CompactPkeCrs} crs\n   * @param {Uint8Array} metadata\n   * @param {ZkComputeLoad} compute_load\n   * @returns {ProvenCompactCiphertextList}\n   */\n  build_with_proof_packed(crs, metadata, compute_load) {\n    _assertClass$1(crs, CompactPkeCrs);\n    const ptr0 = passArray8ToWasm0$1(metadata, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.compactciphertextlistbuilder_build_with_proof_packed(this.__wbg_ptr, crs.__wbg_ptr, ptr0, len0, compute_load);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return ProvenCompactCiphertextList.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   */\n  push_u72(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_u72(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {any} value\n   */\n  push_u80(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_u80(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {any} value\n   */\n  push_u88(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_u88(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {any} value\n   */\n  push_u96(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_u96(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {any} value\n   */\n  push_u104(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_u104(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {any} value\n   */\n  push_u112(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_u112(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {any} value\n   */\n  push_u120(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_u120(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {any} value\n   */\n  push_u136(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_u136(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {any} value\n   */\n  push_u144(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_u144(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {any} value\n   */\n  push_u152(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_u152(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {any} value\n   */\n  push_u168(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_u168(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {any} value\n   */\n  push_u176(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_u176(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {any} value\n   */\n  push_u184(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_u184(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {any} value\n   */\n  push_u192(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_u192(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {any} value\n   */\n  push_u200(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_u200(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {any} value\n   */\n  push_u208(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_u208(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {any} value\n   */\n  push_u216(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_u216(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {any} value\n   */\n  push_u224(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_u224(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {any} value\n   */\n  push_u232(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_u232(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {any} value\n   */\n  push_u240(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_u240(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {any} value\n   */\n  push_u248(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_u248(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {any} value\n   */\n  push_i72(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_i72(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {any} value\n   */\n  push_i80(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_i80(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {any} value\n   */\n  push_i88(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_i88(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {any} value\n   */\n  push_i96(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_i96(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {any} value\n   */\n  push_i104(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_i104(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {any} value\n   */\n  push_i112(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_i112(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {any} value\n   */\n  push_i120(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_i120(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {any} value\n   */\n  push_i136(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_i136(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {any} value\n   */\n  push_i144(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_i144(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {any} value\n   */\n  push_i152(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_i152(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {any} value\n   */\n  push_i168(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_i168(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {any} value\n   */\n  push_i176(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_i176(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {any} value\n   */\n  push_i184(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_i184(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {any} value\n   */\n  push_i192(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_i192(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {any} value\n   */\n  push_i200(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_i200(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {any} value\n   */\n  push_i208(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_i208(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {any} value\n   */\n  push_i216(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_i216(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {any} value\n   */\n  push_i224(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_i224(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {any} value\n   */\n  push_i232(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_i232(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {any} value\n   */\n  push_i240(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_i240(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n  /**\n   * @param {any} value\n   */\n  push_i248(value) {\n    const ret = wasm$1.compactciphertextlistbuilder_push_i248(this.__wbg_ptr, value);\n    if (ret[1]) {\n      throw takeFromExternrefTable0$1(ret[0]);\n    }\n  }\n}\nconst CompactCiphertextListExpanderFinalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_compactciphertextlistexpander_free(ptr >>> 0, 1));\nclass CompactCiphertextListExpander {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(CompactCiphertextListExpander.prototype);\n    obj.__wbg_ptr = ptr;\n    CompactCiphertextListExpanderFinalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    CompactCiphertextListExpanderFinalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_compactciphertextlistexpander_free(ptr, 0);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheUint24}\n   */\n  get_uint24(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_uint24(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint24.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheUint40}\n   */\n  get_uint40(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_uint40(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint40.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheUint48}\n   */\n  get_uint48(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_uint48(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint48.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheUint56}\n   */\n  get_uint56(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_uint56(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint56.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheUint72}\n   */\n  get_uint72(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_uint72(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint72.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheUint80}\n   */\n  get_uint80(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_uint80(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint80.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheUint88}\n   */\n  get_uint88(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_uint88(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint88.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheUint96}\n   */\n  get_uint96(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_uint96(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint96.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheUint104}\n   */\n  get_uint104(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_uint104(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint104.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheUint112}\n   */\n  get_uint112(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_uint112(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint112.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheUint120}\n   */\n  get_uint120(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_uint120(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint120.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheUint136}\n   */\n  get_uint136(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_uint136(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint136.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheUint144}\n   */\n  get_uint144(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_uint144(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint144.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheUint152}\n   */\n  get_uint152(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_uint152(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint152.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheUint168}\n   */\n  get_uint168(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_uint168(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint168.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheUint176}\n   */\n  get_uint176(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_uint176(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint176.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheUint184}\n   */\n  get_uint184(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_uint184(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint184.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheUint192}\n   */\n  get_uint192(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_uint192(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint192.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheUint200}\n   */\n  get_uint200(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_uint200(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint200.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheUint208}\n   */\n  get_uint208(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_uint208(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint208.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheUint216}\n   */\n  get_uint216(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_uint216(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint216.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheUint224}\n   */\n  get_uint224(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_uint224(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint224.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheUint232}\n   */\n  get_uint232(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_uint232(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint232.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheUint240}\n   */\n  get_uint240(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_uint240(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint240.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheUint248}\n   */\n  get_uint248(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_uint248(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint248.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheUint256}\n   */\n  get_uint256(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_uint256(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint256.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheUint2}\n   */\n  get_uint2(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_uint2(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint2.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheUint4}\n   */\n  get_uint4(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_uint4(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint4.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheUint6}\n   */\n  get_uint6(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_uint6(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint6.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheUint8}\n   */\n  get_uint8(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_uint8(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint8.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheUint10}\n   */\n  get_uint10(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_uint10(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint10.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheUint12}\n   */\n  get_uint12(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_uint12(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint12.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheUint14}\n   */\n  get_uint14(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_uint14(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint14.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheUint16}\n   */\n  get_uint16(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_uint16(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint16.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheUint32}\n   */\n  get_uint32(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_uint32(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint32.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheUint64}\n   */\n  get_uint64(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_uint64(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint64.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheUint128}\n   */\n  get_uint128(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_uint128(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint128.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheUint160}\n   */\n  get_uint160(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_uint160(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint160.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheUint512}\n   */\n  get_uint512(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_uint512(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint512.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheUint1024}\n   */\n  get_uint1024(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_uint1024(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint1024.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheUint2048}\n   */\n  get_uint2048(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_uint2048(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint2048.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheInt24}\n   */\n  get_int24(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_int24(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt24.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheInt40}\n   */\n  get_int40(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_int40(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt40.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheInt48}\n   */\n  get_int48(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_int48(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt48.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheInt56}\n   */\n  get_int56(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_int56(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt56.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheInt72}\n   */\n  get_int72(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_int72(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt72.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheInt80}\n   */\n  get_int80(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_int80(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt80.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheInt88}\n   */\n  get_int88(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_int88(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt88.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheInt96}\n   */\n  get_int96(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_int96(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt96.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheInt104}\n   */\n  get_int104(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_int104(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt104.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheInt112}\n   */\n  get_int112(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_int112(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt112.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheInt120}\n   */\n  get_int120(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_int120(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt120.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheInt136}\n   */\n  get_int136(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_int136(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt136.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheInt144}\n   */\n  get_int144(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_int144(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt144.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheInt152}\n   */\n  get_int152(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_int152(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt152.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheInt168}\n   */\n  get_int168(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_int168(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt168.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheInt176}\n   */\n  get_int176(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_int176(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt176.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheInt184}\n   */\n  get_int184(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_int184(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt184.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheInt192}\n   */\n  get_int192(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_int192(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt192.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheInt200}\n   */\n  get_int200(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_int200(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt200.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheInt208}\n   */\n  get_int208(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_int208(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt208.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheInt216}\n   */\n  get_int216(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_int216(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt216.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheInt224}\n   */\n  get_int224(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_int224(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt224.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheInt232}\n   */\n  get_int232(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_int232(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt232.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheInt240}\n   */\n  get_int240(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_int240(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt240.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheInt248}\n   */\n  get_int248(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_int248(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt248.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheInt2}\n   */\n  get_int2(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_int2(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt2.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheInt4}\n   */\n  get_int4(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_int4(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt4.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheInt6}\n   */\n  get_int6(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_int6(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt6.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheInt8}\n   */\n  get_int8(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_int8(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt8.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheInt10}\n   */\n  get_int10(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_int10(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt10.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheInt12}\n   */\n  get_int12(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_int12(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt12.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheInt14}\n   */\n  get_int14(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_int14(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt14.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheInt16}\n   */\n  get_int16(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_int16(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt16.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheInt32}\n   */\n  get_int32(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_int32(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt32.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheInt64}\n   */\n  get_int64(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_int64(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt64.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheInt128}\n   */\n  get_int128(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_int128(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt128.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheInt160}\n   */\n  get_int160(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_int160(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt160.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheInt256}\n   */\n  get_int256(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_int256(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt256.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheInt512}\n   */\n  get_int512(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_int512(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt512.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheInt1024}\n   */\n  get_int1024(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_int1024(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt1024.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheInt2048}\n   */\n  get_int2048(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_int2048(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt2048.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} index\n   * @returns {FheBool}\n   */\n  get_bool(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_bool(this.__wbg_ptr, index);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheBool.__wrap(ret[0]);\n  }\n  /**\n   * @returns {number}\n   */\n  len() {\n    const ret = wasm$1.compactciphertextlistexpander_len(this.__wbg_ptr);\n    return ret >>> 0;\n  }\n  /**\n   * @returns {boolean}\n   */\n  is_empty() {\n    const ret = wasm$1.compactciphertextlistexpander_is_empty(this.__wbg_ptr);\n    return ret !== 0;\n  }\n  /**\n   * @param {number} index\n   * @returns {FheTypes | undefined}\n   */\n  get_kind_of(index) {\n    const ret = wasm$1.compactciphertextlistexpander_get_kind_of(this.__wbg_ptr, index);\n    return ret === 84 ? undefined : ret;\n  }\n}\nconst CompactPkeCrsFinalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_compactpkecrs_free(ptr >>> 0, 1));\nclass CompactPkeCrs {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(CompactPkeCrs.prototype);\n    obj.__wbg_ptr = ptr;\n    CompactPkeCrsFinalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    CompactPkeCrsFinalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_compactpkecrs_free(ptr, 0);\n  }\n  /**\n   * @param {boolean} compress\n   * @returns {Uint8Array}\n   */\n  serialize(compress) {\n    const ret = wasm$1.compactpkecrs_serialize(this.__wbg_ptr, compress);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {CompactPkeCrs}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.compactpkecrs_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return CompactPkeCrs.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.compactpkecrs_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {CompactPkeCrs}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.compactpkecrs_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return CompactPkeCrs.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheConfig} config\n   * @param {number} max_num_bits\n   * @returns {CompactPkeCrs}\n   */\n  static from_config(config, max_num_bits) {\n    _assertClass$1(config, TfheConfig);\n    const ret = wasm$1.compactpkecrs_from_config(config.__wbg_ptr, max_num_bits);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return CompactPkeCrs.__wrap(ret[0]);\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {CompactPkeCrs}\n   */\n  static deserialize_from_public_params(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.compactpkecrs_deserialize_from_public_params(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return CompactPkeCrs.__wrap(ret[0]);\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {CompactPkeCrs}\n   */\n  static safe_deserialize_from_public_params(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.compactpkecrs_safe_deserialize_from_public_params(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return CompactPkeCrs.__wrap(ret[0]);\n  }\n}\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfhebool_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheint10_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheint1024_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheint104_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheint112_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheint12_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheint120_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheint128_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheint136_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheint14_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheint144_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheint152_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheint16_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheint160_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheint168_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheint176_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheint184_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheint192_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheint2_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheint200_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheint2048_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheint208_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheint216_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheint224_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheint232_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheint24_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheint240_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheint248_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheint256_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheint32_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheint4_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheint40_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheint48_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheint512_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheint56_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheint6_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheint64_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheint72_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheint8_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheint80_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheint88_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheint96_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheuint10_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheuint1024_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheuint104_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheuint112_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheuint12_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheuint120_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheuint128_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheuint136_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheuint14_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheuint144_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheuint152_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheuint16_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheuint160_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheuint168_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheuint176_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheuint184_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheuint192_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheuint2_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheuint200_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheuint2048_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheuint208_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheuint216_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheuint224_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheuint232_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheuint24_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheuint240_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheuint248_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheuint256_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheuint32_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheuint4_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheuint40_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheuint48_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheuint512_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheuint56_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheuint6_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheuint64_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheuint72_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheuint8_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheuint80_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheuint88_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheuint96_free(ptr >>> 0, 1));\nconst FheBoolFinalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fhebool_free(ptr >>> 0, 1));\nclass FheBool {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheBool.prototype);\n    obj.__wbg_ptr = ptr;\n    FheBoolFinalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheBoolFinalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fhebool_free(ptr, 0);\n  }\n  /**\n   * @param {boolean} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheBool}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fhebool_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheBool.__wrap(ret[0]);\n  }\n  /**\n   * @param {boolean} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheBool}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fhebool_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheBool.__wrap(ret[0]);\n  }\n  /**\n   * @param {boolean} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheBool}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fhebool_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheBool.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {boolean}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fhebool_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return ret[0] !== 0;\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fhebool_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheBool}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fhebool_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheBool.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fhebool_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheBool}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fhebool_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheBool.__wrap(ret[0]);\n  }\n}\nconst FheInt10Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheint10_free(ptr >>> 0, 1));\nclass FheInt10 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheInt10.prototype);\n    obj.__wbg_ptr = ptr;\n    FheInt10Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheInt10Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheint10_free(ptr, 0);\n  }\n  /**\n   * @param {number} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheInt10}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint10_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt10.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheInt10}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheint10_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt10.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheInt10}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheint10_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt10.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {number}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint10_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return ret[0];\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheint10_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheInt10}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint10_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt10.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheint10_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheInt10}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint10_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt10.__wrap(ret[0]);\n  }\n}\nconst FheInt1024Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheint1024_free(ptr >>> 0, 1));\nclass FheInt1024 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheInt1024.prototype);\n    obj.__wbg_ptr = ptr;\n    FheInt1024Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheInt1024Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheint1024_free(ptr, 0);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheInt1024}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint1024_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt1024.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheInt1024}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheint1024_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt1024.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheInt1024}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheint1024_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt1024.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {any}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint1024_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return takeFromExternrefTable0$1(ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheint1024_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheInt1024}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint1024_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt1024.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheint1024_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheInt1024}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint1024_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt1024.__wrap(ret[0]);\n  }\n}\nconst FheInt104Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheint104_free(ptr >>> 0, 1));\nclass FheInt104 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheInt104.prototype);\n    obj.__wbg_ptr = ptr;\n    FheInt104Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheInt104Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheint104_free(ptr, 0);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheInt104}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint104_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt104.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheInt104}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheint104_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt104.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheInt104}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheint104_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt104.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {any}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint104_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return takeFromExternrefTable0$1(ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheint104_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheInt104}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint104_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt104.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheint104_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheInt104}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint104_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt104.__wrap(ret[0]);\n  }\n}\nconst FheInt112Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheint112_free(ptr >>> 0, 1));\nclass FheInt112 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheInt112.prototype);\n    obj.__wbg_ptr = ptr;\n    FheInt112Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheInt112Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheint112_free(ptr, 0);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheInt112}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint112_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt112.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheInt112}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheint112_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt112.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheInt112}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheint112_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt112.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {any}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint112_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return takeFromExternrefTable0$1(ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheint112_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheInt112}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint112_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt112.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheint112_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheInt112}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint112_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt112.__wrap(ret[0]);\n  }\n}\nconst FheInt12Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheint12_free(ptr >>> 0, 1));\nclass FheInt12 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheInt12.prototype);\n    obj.__wbg_ptr = ptr;\n    FheInt12Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheInt12Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheint12_free(ptr, 0);\n  }\n  /**\n   * @param {number} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheInt12}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint12_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt12.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheInt12}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheint12_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt12.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheInt12}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheint12_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt12.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {number}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint12_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return ret[0];\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheint12_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheInt12}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint12_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt12.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheint12_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheInt12}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint12_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt12.__wrap(ret[0]);\n  }\n}\nconst FheInt120Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheint120_free(ptr >>> 0, 1));\nclass FheInt120 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheInt120.prototype);\n    obj.__wbg_ptr = ptr;\n    FheInt120Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheInt120Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheint120_free(ptr, 0);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheInt120}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint120_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt120.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheInt120}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheint120_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt120.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheInt120}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheint120_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt120.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {any}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint120_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return takeFromExternrefTable0$1(ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheint120_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheInt120}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint120_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt120.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheint120_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheInt120}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint120_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt120.__wrap(ret[0]);\n  }\n}\nconst FheInt128Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheint128_free(ptr >>> 0, 1));\nclass FheInt128 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheInt128.prototype);\n    obj.__wbg_ptr = ptr;\n    FheInt128Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheInt128Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheint128_free(ptr, 0);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheInt128}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint128_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt128.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheInt128}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheint128_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt128.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheInt128}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheint128_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt128.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {any}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint128_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return takeFromExternrefTable0$1(ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheint128_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheInt128}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint128_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt128.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheint128_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheInt128}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint128_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt128.__wrap(ret[0]);\n  }\n}\nconst FheInt136Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheint136_free(ptr >>> 0, 1));\nclass FheInt136 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheInt136.prototype);\n    obj.__wbg_ptr = ptr;\n    FheInt136Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheInt136Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheint136_free(ptr, 0);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheInt136}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint136_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt136.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheInt136}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheint136_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt136.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheInt136}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheint136_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt136.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {any}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint136_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return takeFromExternrefTable0$1(ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheint136_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheInt136}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint136_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt136.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheint136_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheInt136}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint136_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt136.__wrap(ret[0]);\n  }\n}\nconst FheInt14Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheint14_free(ptr >>> 0, 1));\nclass FheInt14 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheInt14.prototype);\n    obj.__wbg_ptr = ptr;\n    FheInt14Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheInt14Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheint14_free(ptr, 0);\n  }\n  /**\n   * @param {number} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheInt14}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint14_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt14.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheInt14}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheint14_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt14.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheInt14}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheint14_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt14.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {number}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint14_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return ret[0];\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheint14_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheInt14}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint14_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt14.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheint14_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheInt14}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint14_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt14.__wrap(ret[0]);\n  }\n}\nconst FheInt144Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheint144_free(ptr >>> 0, 1));\nclass FheInt144 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheInt144.prototype);\n    obj.__wbg_ptr = ptr;\n    FheInt144Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheInt144Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheint144_free(ptr, 0);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheInt144}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint144_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt144.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheInt144}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheint144_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt144.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheInt144}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheint144_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt144.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {any}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint144_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return takeFromExternrefTable0$1(ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheint144_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheInt144}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint144_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt144.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheint144_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheInt144}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint144_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt144.__wrap(ret[0]);\n  }\n}\nconst FheInt152Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheint152_free(ptr >>> 0, 1));\nclass FheInt152 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheInt152.prototype);\n    obj.__wbg_ptr = ptr;\n    FheInt152Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheInt152Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheint152_free(ptr, 0);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheInt152}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint152_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt152.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheInt152}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheint152_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt152.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheInt152}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheint152_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt152.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {any}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint152_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return takeFromExternrefTable0$1(ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheint152_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheInt152}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint152_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt152.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheint152_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheInt152}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint152_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt152.__wrap(ret[0]);\n  }\n}\nconst FheInt16Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheint16_free(ptr >>> 0, 1));\nclass FheInt16 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheInt16.prototype);\n    obj.__wbg_ptr = ptr;\n    FheInt16Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheInt16Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheint16_free(ptr, 0);\n  }\n  /**\n   * @param {number} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheInt16}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint16_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt16.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheInt16}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheint16_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt16.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheInt16}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheint16_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt16.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {number}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint16_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return ret[0];\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheint16_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheInt16}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint16_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt16.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheint16_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheInt16}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint16_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt16.__wrap(ret[0]);\n  }\n}\nconst FheInt160Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheint160_free(ptr >>> 0, 1));\nclass FheInt160 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheInt160.prototype);\n    obj.__wbg_ptr = ptr;\n    FheInt160Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheInt160Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheint160_free(ptr, 0);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheInt160}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint160_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt160.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheInt160}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheint160_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt160.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheInt160}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheint160_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt160.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {any}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint160_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return takeFromExternrefTable0$1(ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheint160_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheInt160}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint160_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt160.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheint160_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheInt160}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint160_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt160.__wrap(ret[0]);\n  }\n}\nconst FheInt168Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheint168_free(ptr >>> 0, 1));\nclass FheInt168 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheInt168.prototype);\n    obj.__wbg_ptr = ptr;\n    FheInt168Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheInt168Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheint168_free(ptr, 0);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheInt168}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint168_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt168.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheInt168}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheint168_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt168.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheInt168}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheint168_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt168.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {any}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint168_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return takeFromExternrefTable0$1(ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheint168_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheInt168}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint168_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt168.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheint168_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheInt168}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint168_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt168.__wrap(ret[0]);\n  }\n}\nconst FheInt176Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheint176_free(ptr >>> 0, 1));\nclass FheInt176 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheInt176.prototype);\n    obj.__wbg_ptr = ptr;\n    FheInt176Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheInt176Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheint176_free(ptr, 0);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheInt176}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint176_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt176.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheInt176}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheint176_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt176.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheInt176}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheint176_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt176.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {any}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint176_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return takeFromExternrefTable0$1(ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheint176_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheInt176}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint176_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt176.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheint176_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheInt176}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint176_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt176.__wrap(ret[0]);\n  }\n}\nconst FheInt184Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheint184_free(ptr >>> 0, 1));\nclass FheInt184 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheInt184.prototype);\n    obj.__wbg_ptr = ptr;\n    FheInt184Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheInt184Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheint184_free(ptr, 0);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheInt184}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint184_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt184.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheInt184}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheint184_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt184.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheInt184}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheint184_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt184.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {any}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint184_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return takeFromExternrefTable0$1(ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheint184_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheInt184}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint184_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt184.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheint184_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheInt184}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint184_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt184.__wrap(ret[0]);\n  }\n}\nconst FheInt192Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheint192_free(ptr >>> 0, 1));\nclass FheInt192 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheInt192.prototype);\n    obj.__wbg_ptr = ptr;\n    FheInt192Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheInt192Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheint192_free(ptr, 0);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheInt192}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint192_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt192.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheInt192}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheint192_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt192.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheInt192}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheint192_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt192.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {any}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint192_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return takeFromExternrefTable0$1(ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheint192_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheInt192}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint192_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt192.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheint192_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheInt192}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint192_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt192.__wrap(ret[0]);\n  }\n}\nconst FheInt2Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheint2_free(ptr >>> 0, 1));\nclass FheInt2 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheInt2.prototype);\n    obj.__wbg_ptr = ptr;\n    FheInt2Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheInt2Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheint2_free(ptr, 0);\n  }\n  /**\n   * @param {number} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheInt2}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint2_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt2.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheInt2}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheint2_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt2.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheInt2}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheint2_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt2.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {number}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint2_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return ret[0];\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheint2_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheInt2}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint2_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt2.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheint2_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheInt2}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint2_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt2.__wrap(ret[0]);\n  }\n}\nconst FheInt200Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheint200_free(ptr >>> 0, 1));\nclass FheInt200 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheInt200.prototype);\n    obj.__wbg_ptr = ptr;\n    FheInt200Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheInt200Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheint200_free(ptr, 0);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheInt200}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint200_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt200.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheInt200}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheint200_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt200.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheInt200}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheint200_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt200.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {any}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint200_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return takeFromExternrefTable0$1(ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheint200_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheInt200}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint200_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt200.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheint200_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheInt200}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint200_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt200.__wrap(ret[0]);\n  }\n}\nconst FheInt2048Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheint2048_free(ptr >>> 0, 1));\nclass FheInt2048 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheInt2048.prototype);\n    obj.__wbg_ptr = ptr;\n    FheInt2048Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheInt2048Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheint2048_free(ptr, 0);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheInt2048}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint2048_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt2048.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheInt2048}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheint2048_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt2048.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheInt2048}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheint2048_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt2048.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {any}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint2048_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return takeFromExternrefTable0$1(ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheint2048_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheInt2048}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint2048_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt2048.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheint2048_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheInt2048}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint2048_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt2048.__wrap(ret[0]);\n  }\n}\nconst FheInt208Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheint208_free(ptr >>> 0, 1));\nclass FheInt208 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheInt208.prototype);\n    obj.__wbg_ptr = ptr;\n    FheInt208Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheInt208Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheint208_free(ptr, 0);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheInt208}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint208_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt208.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheInt208}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheint208_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt208.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheInt208}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheint208_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt208.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {any}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint208_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return takeFromExternrefTable0$1(ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheint208_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheInt208}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint208_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt208.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheint208_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheInt208}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint208_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt208.__wrap(ret[0]);\n  }\n}\nconst FheInt216Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheint216_free(ptr >>> 0, 1));\nclass FheInt216 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheInt216.prototype);\n    obj.__wbg_ptr = ptr;\n    FheInt216Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheInt216Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheint216_free(ptr, 0);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheInt216}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint216_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt216.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheInt216}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheint216_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt216.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheInt216}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheint216_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt216.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {any}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint216_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return takeFromExternrefTable0$1(ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheint216_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheInt216}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint216_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt216.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheint216_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheInt216}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint216_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt216.__wrap(ret[0]);\n  }\n}\nconst FheInt224Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheint224_free(ptr >>> 0, 1));\nclass FheInt224 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheInt224.prototype);\n    obj.__wbg_ptr = ptr;\n    FheInt224Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheInt224Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheint224_free(ptr, 0);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheInt224}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint224_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt224.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheInt224}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheint224_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt224.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheInt224}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheint224_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt224.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {any}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint224_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return takeFromExternrefTable0$1(ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheint224_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheInt224}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint224_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt224.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheint224_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheInt224}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint224_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt224.__wrap(ret[0]);\n  }\n}\nconst FheInt232Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheint232_free(ptr >>> 0, 1));\nclass FheInt232 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheInt232.prototype);\n    obj.__wbg_ptr = ptr;\n    FheInt232Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheInt232Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheint232_free(ptr, 0);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheInt232}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint232_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt232.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheInt232}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheint232_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt232.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheInt232}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheint232_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt232.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {any}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint232_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return takeFromExternrefTable0$1(ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheint232_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheInt232}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint232_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt232.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheint232_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheInt232}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint232_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt232.__wrap(ret[0]);\n  }\n}\nconst FheInt24Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheint24_free(ptr >>> 0, 1));\nclass FheInt24 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheInt24.prototype);\n    obj.__wbg_ptr = ptr;\n    FheInt24Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheInt24Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheint24_free(ptr, 0);\n  }\n  /**\n   * @param {number} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheInt24}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint24_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt24.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheInt24}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheint24_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt24.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheInt24}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheint24_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt24.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {number}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint24_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return ret[0];\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheint24_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheInt24}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint24_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt24.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheint24_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheInt24}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint24_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt24.__wrap(ret[0]);\n  }\n}\nconst FheInt240Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheint240_free(ptr >>> 0, 1));\nclass FheInt240 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheInt240.prototype);\n    obj.__wbg_ptr = ptr;\n    FheInt240Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheInt240Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheint240_free(ptr, 0);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheInt240}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint240_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt240.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheInt240}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheint240_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt240.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheInt240}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheint240_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt240.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {any}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint240_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return takeFromExternrefTable0$1(ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheint240_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheInt240}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint240_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt240.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheint240_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheInt240}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint240_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt240.__wrap(ret[0]);\n  }\n}\nconst FheInt248Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheint248_free(ptr >>> 0, 1));\nclass FheInt248 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheInt248.prototype);\n    obj.__wbg_ptr = ptr;\n    FheInt248Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheInt248Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheint248_free(ptr, 0);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheInt248}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint248_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt248.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheInt248}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheint248_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt248.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheInt248}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheint248_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt248.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {any}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint248_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return takeFromExternrefTable0$1(ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheint248_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheInt248}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint248_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt248.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheint248_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheInt248}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint248_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt248.__wrap(ret[0]);\n  }\n}\nconst FheInt256Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheint256_free(ptr >>> 0, 1));\nclass FheInt256 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheInt256.prototype);\n    obj.__wbg_ptr = ptr;\n    FheInt256Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheInt256Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheint256_free(ptr, 0);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheInt256}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint256_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt256.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheInt256}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheint256_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt256.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheInt256}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheint256_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt256.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {any}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint256_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return takeFromExternrefTable0$1(ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheint256_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheInt256}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint256_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt256.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheint256_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheInt256}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint256_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt256.__wrap(ret[0]);\n  }\n}\nconst FheInt32Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheint32_free(ptr >>> 0, 1));\nclass FheInt32 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheInt32.prototype);\n    obj.__wbg_ptr = ptr;\n    FheInt32Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheInt32Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheint32_free(ptr, 0);\n  }\n  /**\n   * @param {number} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheInt32}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint32_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt32.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheInt32}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheint32_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt32.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheInt32}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheint32_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt32.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {number}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint32_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return ret[0];\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheint32_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheInt32}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint32_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt32.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheint32_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheInt32}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint32_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt32.__wrap(ret[0]);\n  }\n}\nconst FheInt4Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheint4_free(ptr >>> 0, 1));\nclass FheInt4 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheInt4.prototype);\n    obj.__wbg_ptr = ptr;\n    FheInt4Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheInt4Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheint4_free(ptr, 0);\n  }\n  /**\n   * @param {number} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheInt4}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint4_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt4.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheInt4}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheint4_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt4.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheInt4}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheint4_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt4.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {number}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint4_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return ret[0];\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheint4_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheInt4}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint4_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt4.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheint4_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheInt4}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint4_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt4.__wrap(ret[0]);\n  }\n}\nconst FheInt40Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheint40_free(ptr >>> 0, 1));\nclass FheInt40 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheInt40.prototype);\n    obj.__wbg_ptr = ptr;\n    FheInt40Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheInt40Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheint40_free(ptr, 0);\n  }\n  /**\n   * @param {bigint} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheInt40}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint40_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt40.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheInt40}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheint40_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt40.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheInt40}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheint40_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt40.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {bigint}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint40_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return ret[0];\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheint40_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheInt40}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint40_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt40.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheint40_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheInt40}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint40_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt40.__wrap(ret[0]);\n  }\n}\nconst FheInt48Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheint48_free(ptr >>> 0, 1));\nclass FheInt48 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheInt48.prototype);\n    obj.__wbg_ptr = ptr;\n    FheInt48Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheInt48Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheint48_free(ptr, 0);\n  }\n  /**\n   * @param {bigint} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheInt48}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint48_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt48.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheInt48}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheint48_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt48.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheInt48}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheint48_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt48.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {bigint}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint48_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return ret[0];\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheint48_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheInt48}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint48_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt48.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheint48_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheInt48}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint48_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt48.__wrap(ret[0]);\n  }\n}\nconst FheInt512Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheint512_free(ptr >>> 0, 1));\nclass FheInt512 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheInt512.prototype);\n    obj.__wbg_ptr = ptr;\n    FheInt512Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheInt512Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheint512_free(ptr, 0);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheInt512}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint512_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt512.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheInt512}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheint512_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt512.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheInt512}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheint512_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt512.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {any}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint512_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return takeFromExternrefTable0$1(ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheint512_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheInt512}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint512_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt512.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheint512_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheInt512}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint512_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt512.__wrap(ret[0]);\n  }\n}\nconst FheInt56Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheint56_free(ptr >>> 0, 1));\nclass FheInt56 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheInt56.prototype);\n    obj.__wbg_ptr = ptr;\n    FheInt56Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheInt56Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheint56_free(ptr, 0);\n  }\n  /**\n   * @param {bigint} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheInt56}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint56_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt56.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheInt56}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheint56_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt56.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheInt56}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheint56_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt56.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {bigint}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint56_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return ret[0];\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheint56_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheInt56}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint56_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt56.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheint56_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheInt56}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint56_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt56.__wrap(ret[0]);\n  }\n}\nconst FheInt6Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheint6_free(ptr >>> 0, 1));\nclass FheInt6 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheInt6.prototype);\n    obj.__wbg_ptr = ptr;\n    FheInt6Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheInt6Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheint6_free(ptr, 0);\n  }\n  /**\n   * @param {number} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheInt6}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint6_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt6.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheInt6}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheint6_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt6.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheInt6}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheint6_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt6.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {number}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint6_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return ret[0];\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheint6_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheInt6}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint6_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt6.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheint6_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheInt6}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint6_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt6.__wrap(ret[0]);\n  }\n}\nconst FheInt64Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheint64_free(ptr >>> 0, 1));\nclass FheInt64 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheInt64.prototype);\n    obj.__wbg_ptr = ptr;\n    FheInt64Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheInt64Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheint64_free(ptr, 0);\n  }\n  /**\n   * @param {bigint} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheInt64}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint64_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt64.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheInt64}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheint64_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt64.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheInt64}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheint64_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt64.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {bigint}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint64_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return ret[0];\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheint64_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheInt64}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint64_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt64.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheint64_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheInt64}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint64_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt64.__wrap(ret[0]);\n  }\n}\nconst FheInt72Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheint72_free(ptr >>> 0, 1));\nclass FheInt72 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheInt72.prototype);\n    obj.__wbg_ptr = ptr;\n    FheInt72Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheInt72Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheint72_free(ptr, 0);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheInt72}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint72_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt72.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheInt72}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheint72_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt72.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheInt72}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheint72_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt72.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {any}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint72_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return takeFromExternrefTable0$1(ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheint72_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheInt72}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint72_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt72.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheint72_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheInt72}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint72_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt72.__wrap(ret[0]);\n  }\n}\nconst FheInt8Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheint8_free(ptr >>> 0, 1));\nclass FheInt8 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheInt8.prototype);\n    obj.__wbg_ptr = ptr;\n    FheInt8Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheInt8Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheint8_free(ptr, 0);\n  }\n  /**\n   * @param {number} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheInt8}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint8_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt8.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheInt8}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheint8_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt8.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheInt8}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheint8_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt8.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {number}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint8_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return ret[0];\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheint8_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheInt8}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint8_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt8.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheint8_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheInt8}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint8_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt8.__wrap(ret[0]);\n  }\n}\nconst FheInt80Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheint80_free(ptr >>> 0, 1));\nclass FheInt80 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheInt80.prototype);\n    obj.__wbg_ptr = ptr;\n    FheInt80Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheInt80Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheint80_free(ptr, 0);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheInt80}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint80_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt80.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheInt80}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheint80_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt80.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheInt80}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheint80_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt80.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {any}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint80_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return takeFromExternrefTable0$1(ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheint80_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheInt80}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint80_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt80.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheint80_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheInt80}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint80_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt80.__wrap(ret[0]);\n  }\n}\nconst FheInt88Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheint88_free(ptr >>> 0, 1));\nclass FheInt88 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheInt88.prototype);\n    obj.__wbg_ptr = ptr;\n    FheInt88Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheInt88Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheint88_free(ptr, 0);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheInt88}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint88_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt88.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheInt88}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheint88_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt88.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheInt88}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheint88_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt88.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {any}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint88_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return takeFromExternrefTable0$1(ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheint88_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheInt88}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint88_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt88.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheint88_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheInt88}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint88_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt88.__wrap(ret[0]);\n  }\n}\nconst FheInt96Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheint96_free(ptr >>> 0, 1));\nclass FheInt96 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheInt96.prototype);\n    obj.__wbg_ptr = ptr;\n    FheInt96Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheInt96Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheint96_free(ptr, 0);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheInt96}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint96_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt96.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheInt96}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheint96_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt96.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheInt96}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheint96_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt96.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {any}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheint96_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return takeFromExternrefTable0$1(ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheint96_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheInt96}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint96_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt96.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheint96_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheInt96}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheint96_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheInt96.__wrap(ret[0]);\n  }\n}\nconst FheUint10Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheuint10_free(ptr >>> 0, 1));\nclass FheUint10 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheUint10.prototype);\n    obj.__wbg_ptr = ptr;\n    FheUint10Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheUint10Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheuint10_free(ptr, 0);\n  }\n  /**\n   * @param {number} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheUint10}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint10_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint10.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheUint10}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheuint10_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint10.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheUint10}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheuint10_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint10.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {number}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint10_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return ret[0];\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheuint10_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheUint10}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint10_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint10.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheuint10_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheUint10}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint10_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint10.__wrap(ret[0]);\n  }\n}\nconst FheUint1024Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheuint1024_free(ptr >>> 0, 1));\nclass FheUint1024 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheUint1024.prototype);\n    obj.__wbg_ptr = ptr;\n    FheUint1024Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheUint1024Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheuint1024_free(ptr, 0);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheUint1024}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint1024_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint1024.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheUint1024}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheuint1024_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint1024.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheUint1024}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheuint1024_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint1024.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {any}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint1024_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return takeFromExternrefTable0$1(ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheuint1024_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheUint1024}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint1024_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint1024.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheuint1024_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheUint1024}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint1024_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint1024.__wrap(ret[0]);\n  }\n}\nconst FheUint104Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheuint104_free(ptr >>> 0, 1));\nclass FheUint104 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheUint104.prototype);\n    obj.__wbg_ptr = ptr;\n    FheUint104Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheUint104Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheuint104_free(ptr, 0);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheUint104}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint104_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint104.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheUint104}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheuint104_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint104.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheUint104}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheuint104_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint104.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {any}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint104_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return takeFromExternrefTable0$1(ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheuint104_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheUint104}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint104_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint104.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheuint104_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheUint104}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint104_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint104.__wrap(ret[0]);\n  }\n}\nconst FheUint112Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheuint112_free(ptr >>> 0, 1));\nclass FheUint112 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheUint112.prototype);\n    obj.__wbg_ptr = ptr;\n    FheUint112Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheUint112Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheuint112_free(ptr, 0);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheUint112}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint112_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint112.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheUint112}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheuint112_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint112.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheUint112}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheuint112_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint112.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {any}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint112_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return takeFromExternrefTable0$1(ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheuint112_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheUint112}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint112_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint112.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheuint112_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheUint112}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint112_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint112.__wrap(ret[0]);\n  }\n}\nconst FheUint12Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheuint12_free(ptr >>> 0, 1));\nclass FheUint12 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheUint12.prototype);\n    obj.__wbg_ptr = ptr;\n    FheUint12Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheUint12Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheuint12_free(ptr, 0);\n  }\n  /**\n   * @param {number} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheUint12}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint12_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint12.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheUint12}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheuint12_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint12.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheUint12}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheuint12_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint12.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {number}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint12_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return ret[0];\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheuint12_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheUint12}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint12_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint12.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheuint12_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheUint12}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint12_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint12.__wrap(ret[0]);\n  }\n}\nconst FheUint120Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheuint120_free(ptr >>> 0, 1));\nclass FheUint120 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheUint120.prototype);\n    obj.__wbg_ptr = ptr;\n    FheUint120Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheUint120Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheuint120_free(ptr, 0);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheUint120}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint120_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint120.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheUint120}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheuint120_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint120.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheUint120}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheuint120_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint120.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {any}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint120_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return takeFromExternrefTable0$1(ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheuint120_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheUint120}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint120_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint120.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheuint120_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheUint120}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint120_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint120.__wrap(ret[0]);\n  }\n}\nconst FheUint128Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheuint128_free(ptr >>> 0, 1));\nclass FheUint128 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheUint128.prototype);\n    obj.__wbg_ptr = ptr;\n    FheUint128Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheUint128Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheuint128_free(ptr, 0);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheUint128}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint128_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint128.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheUint128}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheuint128_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint128.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheUint128}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheuint128_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint128.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {any}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint128_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return takeFromExternrefTable0$1(ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheuint128_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheUint128}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint128_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint128.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheuint128_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheUint128}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint128_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint128.__wrap(ret[0]);\n  }\n}\nconst FheUint136Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheuint136_free(ptr >>> 0, 1));\nclass FheUint136 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheUint136.prototype);\n    obj.__wbg_ptr = ptr;\n    FheUint136Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheUint136Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheuint136_free(ptr, 0);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheUint136}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint136_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint136.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheUint136}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheuint136_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint136.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheUint136}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheuint136_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint136.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {any}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint136_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return takeFromExternrefTable0$1(ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheuint136_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheUint136}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint136_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint136.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheuint136_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheUint136}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint136_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint136.__wrap(ret[0]);\n  }\n}\nconst FheUint14Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheuint14_free(ptr >>> 0, 1));\nclass FheUint14 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheUint14.prototype);\n    obj.__wbg_ptr = ptr;\n    FheUint14Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheUint14Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheuint14_free(ptr, 0);\n  }\n  /**\n   * @param {number} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheUint14}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint14_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint14.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheUint14}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheuint14_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint14.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheUint14}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheuint14_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint14.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {number}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint14_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return ret[0];\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheuint14_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheUint14}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint14_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint14.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheuint14_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheUint14}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint14_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint14.__wrap(ret[0]);\n  }\n}\nconst FheUint144Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheuint144_free(ptr >>> 0, 1));\nclass FheUint144 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheUint144.prototype);\n    obj.__wbg_ptr = ptr;\n    FheUint144Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheUint144Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheuint144_free(ptr, 0);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheUint144}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint144_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint144.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheUint144}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheuint144_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint144.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheUint144}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheuint144_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint144.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {any}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint144_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return takeFromExternrefTable0$1(ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheuint144_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheUint144}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint144_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint144.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheuint144_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheUint144}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint144_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint144.__wrap(ret[0]);\n  }\n}\nconst FheUint152Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheuint152_free(ptr >>> 0, 1));\nclass FheUint152 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheUint152.prototype);\n    obj.__wbg_ptr = ptr;\n    FheUint152Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheUint152Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheuint152_free(ptr, 0);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheUint152}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint152_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint152.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheUint152}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheuint152_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint152.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheUint152}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheuint152_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint152.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {any}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint152_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return takeFromExternrefTable0$1(ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheuint152_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheUint152}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint152_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint152.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheuint152_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheUint152}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint152_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint152.__wrap(ret[0]);\n  }\n}\nconst FheUint16Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheuint16_free(ptr >>> 0, 1));\nclass FheUint16 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheUint16.prototype);\n    obj.__wbg_ptr = ptr;\n    FheUint16Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheUint16Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheuint16_free(ptr, 0);\n  }\n  /**\n   * @param {number} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheUint16}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint16_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint16.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheUint16}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheuint16_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint16.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheUint16}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheuint16_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint16.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {number}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint16_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return ret[0];\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheuint16_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheUint16}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint16_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint16.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheuint16_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheUint16}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint16_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint16.__wrap(ret[0]);\n  }\n}\nconst FheUint160Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheuint160_free(ptr >>> 0, 1));\nclass FheUint160 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheUint160.prototype);\n    obj.__wbg_ptr = ptr;\n    FheUint160Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheUint160Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheuint160_free(ptr, 0);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheUint160}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint160_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint160.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheUint160}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheuint160_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint160.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheUint160}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheuint160_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint160.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {any}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint160_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return takeFromExternrefTable0$1(ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheuint160_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheUint160}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint160_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint160.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheuint160_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheUint160}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint160_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint160.__wrap(ret[0]);\n  }\n}\nconst FheUint168Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheuint168_free(ptr >>> 0, 1));\nclass FheUint168 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheUint168.prototype);\n    obj.__wbg_ptr = ptr;\n    FheUint168Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheUint168Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheuint168_free(ptr, 0);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheUint168}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint168_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint168.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheUint168}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheuint168_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint168.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheUint168}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheuint168_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint168.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {any}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint168_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return takeFromExternrefTable0$1(ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheuint168_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheUint168}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint168_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint168.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheuint168_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheUint168}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint168_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint168.__wrap(ret[0]);\n  }\n}\nconst FheUint176Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheuint176_free(ptr >>> 0, 1));\nclass FheUint176 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheUint176.prototype);\n    obj.__wbg_ptr = ptr;\n    FheUint176Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheUint176Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheuint176_free(ptr, 0);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheUint176}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint176_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint176.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheUint176}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheuint176_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint176.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheUint176}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheuint176_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint176.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {any}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint176_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return takeFromExternrefTable0$1(ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheuint176_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheUint176}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint176_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint176.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheuint176_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheUint176}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint176_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint176.__wrap(ret[0]);\n  }\n}\nconst FheUint184Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheuint184_free(ptr >>> 0, 1));\nclass FheUint184 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheUint184.prototype);\n    obj.__wbg_ptr = ptr;\n    FheUint184Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheUint184Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheuint184_free(ptr, 0);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheUint184}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint184_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint184.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheUint184}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheuint184_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint184.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheUint184}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheuint184_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint184.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {any}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint184_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return takeFromExternrefTable0$1(ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheuint184_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheUint184}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint184_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint184.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheuint184_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheUint184}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint184_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint184.__wrap(ret[0]);\n  }\n}\nconst FheUint192Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheuint192_free(ptr >>> 0, 1));\nclass FheUint192 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheUint192.prototype);\n    obj.__wbg_ptr = ptr;\n    FheUint192Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheUint192Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheuint192_free(ptr, 0);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheUint192}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint192_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint192.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheUint192}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheuint192_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint192.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheUint192}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheuint192_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint192.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {any}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint192_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return takeFromExternrefTable0$1(ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheuint192_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheUint192}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint192_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint192.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheuint192_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheUint192}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint192_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint192.__wrap(ret[0]);\n  }\n}\nconst FheUint2Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheuint2_free(ptr >>> 0, 1));\nclass FheUint2 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheUint2.prototype);\n    obj.__wbg_ptr = ptr;\n    FheUint2Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheUint2Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheuint2_free(ptr, 0);\n  }\n  /**\n   * @param {number} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheUint2}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint2_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint2.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheUint2}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheuint2_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint2.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheUint2}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheuint2_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint2.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {number}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint2_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return ret[0];\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheuint2_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheUint2}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint2_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint2.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheuint2_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheUint2}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint2_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint2.__wrap(ret[0]);\n  }\n}\nconst FheUint200Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheuint200_free(ptr >>> 0, 1));\nclass FheUint200 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheUint200.prototype);\n    obj.__wbg_ptr = ptr;\n    FheUint200Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheUint200Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheuint200_free(ptr, 0);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheUint200}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint200_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint200.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheUint200}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheuint200_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint200.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheUint200}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheuint200_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint200.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {any}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint200_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return takeFromExternrefTable0$1(ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheuint200_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheUint200}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint200_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint200.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheuint200_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheUint200}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint200_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint200.__wrap(ret[0]);\n  }\n}\nconst FheUint2048Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheuint2048_free(ptr >>> 0, 1));\nclass FheUint2048 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheUint2048.prototype);\n    obj.__wbg_ptr = ptr;\n    FheUint2048Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheUint2048Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheuint2048_free(ptr, 0);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheUint2048}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint2048_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint2048.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheUint2048}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheuint2048_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint2048.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheUint2048}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheuint2048_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint2048.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {any}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint2048_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return takeFromExternrefTable0$1(ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheuint2048_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheUint2048}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint2048_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint2048.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheuint2048_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheUint2048}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint2048_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint2048.__wrap(ret[0]);\n  }\n}\nconst FheUint208Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheuint208_free(ptr >>> 0, 1));\nclass FheUint208 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheUint208.prototype);\n    obj.__wbg_ptr = ptr;\n    FheUint208Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheUint208Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheuint208_free(ptr, 0);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheUint208}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint208_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint208.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheUint208}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheuint208_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint208.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheUint208}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheuint208_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint208.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {any}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint208_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return takeFromExternrefTable0$1(ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheuint208_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheUint208}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint208_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint208.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheuint208_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheUint208}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint208_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint208.__wrap(ret[0]);\n  }\n}\nconst FheUint216Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheuint216_free(ptr >>> 0, 1));\nclass FheUint216 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheUint216.prototype);\n    obj.__wbg_ptr = ptr;\n    FheUint216Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheUint216Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheuint216_free(ptr, 0);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheUint216}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint216_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint216.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheUint216}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheuint216_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint216.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheUint216}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheuint216_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint216.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {any}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint216_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return takeFromExternrefTable0$1(ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheuint216_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheUint216}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint216_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint216.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheuint216_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheUint216}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint216_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint216.__wrap(ret[0]);\n  }\n}\nconst FheUint224Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheuint224_free(ptr >>> 0, 1));\nclass FheUint224 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheUint224.prototype);\n    obj.__wbg_ptr = ptr;\n    FheUint224Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheUint224Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheuint224_free(ptr, 0);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheUint224}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint224_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint224.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheUint224}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheuint224_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint224.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheUint224}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheuint224_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint224.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {any}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint224_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return takeFromExternrefTable0$1(ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheuint224_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheUint224}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint224_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint224.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheuint224_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheUint224}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint224_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint224.__wrap(ret[0]);\n  }\n}\nconst FheUint232Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheuint232_free(ptr >>> 0, 1));\nclass FheUint232 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheUint232.prototype);\n    obj.__wbg_ptr = ptr;\n    FheUint232Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheUint232Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheuint232_free(ptr, 0);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheUint232}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint232_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint232.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheUint232}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheuint232_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint232.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheUint232}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheuint232_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint232.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {any}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint232_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return takeFromExternrefTable0$1(ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheuint232_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheUint232}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint232_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint232.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheuint232_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheUint232}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint232_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint232.__wrap(ret[0]);\n  }\n}\nconst FheUint24Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheuint24_free(ptr >>> 0, 1));\nclass FheUint24 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheUint24.prototype);\n    obj.__wbg_ptr = ptr;\n    FheUint24Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheUint24Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheuint24_free(ptr, 0);\n  }\n  /**\n   * @param {number} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheUint24}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint24_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint24.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheUint24}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheuint24_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint24.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheUint24}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheuint24_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint24.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {number}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint24_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return ret[0] >>> 0;\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheuint24_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheUint24}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint24_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint24.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheuint24_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheUint24}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint24_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint24.__wrap(ret[0]);\n  }\n}\nconst FheUint240Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheuint240_free(ptr >>> 0, 1));\nclass FheUint240 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheUint240.prototype);\n    obj.__wbg_ptr = ptr;\n    FheUint240Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheUint240Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheuint240_free(ptr, 0);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheUint240}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint240_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint240.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheUint240}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheuint240_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint240.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheUint240}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheuint240_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint240.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {any}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint240_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return takeFromExternrefTable0$1(ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheuint240_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheUint240}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint240_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint240.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheuint240_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheUint240}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint240_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint240.__wrap(ret[0]);\n  }\n}\nconst FheUint248Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheuint248_free(ptr >>> 0, 1));\nclass FheUint248 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheUint248.prototype);\n    obj.__wbg_ptr = ptr;\n    FheUint248Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheUint248Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheuint248_free(ptr, 0);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheUint248}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint248_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint248.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheUint248}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheuint248_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint248.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheUint248}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheuint248_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint248.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {any}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint248_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return takeFromExternrefTable0$1(ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheuint248_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheUint248}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint248_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint248.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheuint248_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheUint248}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint248_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint248.__wrap(ret[0]);\n  }\n}\nconst FheUint256Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheuint256_free(ptr >>> 0, 1));\nclass FheUint256 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheUint256.prototype);\n    obj.__wbg_ptr = ptr;\n    FheUint256Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheUint256Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheuint256_free(ptr, 0);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheUint256}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint256_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint256.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheUint256}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheuint256_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint256.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheUint256}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheuint256_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint256.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {any}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint256_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return takeFromExternrefTable0$1(ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheuint256_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheUint256}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint256_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint256.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheuint256_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheUint256}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint256_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint256.__wrap(ret[0]);\n  }\n}\nconst FheUint32Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheuint32_free(ptr >>> 0, 1));\nclass FheUint32 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheUint32.prototype);\n    obj.__wbg_ptr = ptr;\n    FheUint32Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheUint32Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheuint32_free(ptr, 0);\n  }\n  /**\n   * @param {number} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheUint32}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint32_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint32.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheUint32}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheuint32_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint32.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheUint32}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheuint32_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint32.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {number}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint32_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return ret[0] >>> 0;\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheuint32_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheUint32}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint32_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint32.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheuint32_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheUint32}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint32_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint32.__wrap(ret[0]);\n  }\n}\nconst FheUint4Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheuint4_free(ptr >>> 0, 1));\nclass FheUint4 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheUint4.prototype);\n    obj.__wbg_ptr = ptr;\n    FheUint4Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheUint4Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheuint4_free(ptr, 0);\n  }\n  /**\n   * @param {number} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheUint4}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint4_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint4.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheUint4}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheuint4_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint4.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheUint4}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheuint4_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint4.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {number}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint4_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return ret[0];\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheuint4_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheUint4}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint4_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint4.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheuint4_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheUint4}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint4_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint4.__wrap(ret[0]);\n  }\n}\nconst FheUint40Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheuint40_free(ptr >>> 0, 1));\nclass FheUint40 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheUint40.prototype);\n    obj.__wbg_ptr = ptr;\n    FheUint40Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheUint40Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheuint40_free(ptr, 0);\n  }\n  /**\n   * @param {bigint} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheUint40}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint40_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint40.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheUint40}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheuint40_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint40.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheUint40}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheuint40_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint40.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {bigint}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint40_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return BigInt.asUintN(64, ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheuint40_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheUint40}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint40_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint40.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheuint40_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheUint40}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint40_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint40.__wrap(ret[0]);\n  }\n}\nconst FheUint48Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheuint48_free(ptr >>> 0, 1));\nclass FheUint48 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheUint48.prototype);\n    obj.__wbg_ptr = ptr;\n    FheUint48Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheUint48Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheuint48_free(ptr, 0);\n  }\n  /**\n   * @param {bigint} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheUint48}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint48_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint48.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheUint48}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheuint48_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint48.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheUint48}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheuint48_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint48.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {bigint}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint48_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return BigInt.asUintN(64, ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheuint48_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheUint48}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint48_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint48.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheuint48_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheUint48}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint48_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint48.__wrap(ret[0]);\n  }\n}\nconst FheUint512Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheuint512_free(ptr >>> 0, 1));\nclass FheUint512 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheUint512.prototype);\n    obj.__wbg_ptr = ptr;\n    FheUint512Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheUint512Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheuint512_free(ptr, 0);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheUint512}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint512_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint512.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheUint512}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheuint512_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint512.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheUint512}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheuint512_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint512.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {any}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint512_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return takeFromExternrefTable0$1(ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheuint512_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheUint512}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint512_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint512.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheuint512_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheUint512}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint512_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint512.__wrap(ret[0]);\n  }\n}\nconst FheUint56Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheuint56_free(ptr >>> 0, 1));\nclass FheUint56 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheUint56.prototype);\n    obj.__wbg_ptr = ptr;\n    FheUint56Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheUint56Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheuint56_free(ptr, 0);\n  }\n  /**\n   * @param {bigint} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheUint56}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint56_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint56.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheUint56}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheuint56_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint56.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheUint56}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheuint56_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint56.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {bigint}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint56_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return BigInt.asUintN(64, ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheuint56_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheUint56}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint56_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint56.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheuint56_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheUint56}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint56_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint56.__wrap(ret[0]);\n  }\n}\nconst FheUint6Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheuint6_free(ptr >>> 0, 1));\nclass FheUint6 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheUint6.prototype);\n    obj.__wbg_ptr = ptr;\n    FheUint6Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheUint6Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheuint6_free(ptr, 0);\n  }\n  /**\n   * @param {number} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheUint6}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint6_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint6.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheUint6}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheuint6_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint6.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheUint6}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheuint6_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint6.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {number}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint6_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return ret[0];\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheuint6_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheUint6}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint6_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint6.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheuint6_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheUint6}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint6_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint6.__wrap(ret[0]);\n  }\n}\nconst FheUint64Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheuint64_free(ptr >>> 0, 1));\nclass FheUint64 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheUint64.prototype);\n    obj.__wbg_ptr = ptr;\n    FheUint64Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheUint64Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheuint64_free(ptr, 0);\n  }\n  /**\n   * @param {bigint} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheUint64}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint64_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint64.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheUint64}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheuint64_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint64.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheUint64}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheuint64_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint64.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {bigint}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint64_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return BigInt.asUintN(64, ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheuint64_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheUint64}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint64_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint64.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheuint64_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheUint64}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint64_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint64.__wrap(ret[0]);\n  }\n}\nconst FheUint72Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheuint72_free(ptr >>> 0, 1));\nclass FheUint72 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheUint72.prototype);\n    obj.__wbg_ptr = ptr;\n    FheUint72Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheUint72Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheuint72_free(ptr, 0);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheUint72}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint72_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint72.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheUint72}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheuint72_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint72.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheUint72}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheuint72_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint72.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {any}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint72_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return takeFromExternrefTable0$1(ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheuint72_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheUint72}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint72_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint72.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheuint72_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheUint72}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint72_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint72.__wrap(ret[0]);\n  }\n}\nconst FheUint8Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheuint8_free(ptr >>> 0, 1));\nclass FheUint8 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheUint8.prototype);\n    obj.__wbg_ptr = ptr;\n    FheUint8Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheUint8Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheuint8_free(ptr, 0);\n  }\n  /**\n   * @param {number} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheUint8}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint8_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint8.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheUint8}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheuint8_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint8.__wrap(ret[0]);\n  }\n  /**\n   * @param {number} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheUint8}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheuint8_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint8.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {number}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint8_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return ret[0];\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheuint8_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheUint8}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint8_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint8.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheuint8_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheUint8}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint8_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint8.__wrap(ret[0]);\n  }\n}\nconst FheUint80Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheuint80_free(ptr >>> 0, 1));\nclass FheUint80 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheUint80.prototype);\n    obj.__wbg_ptr = ptr;\n    FheUint80Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheUint80Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheuint80_free(ptr, 0);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheUint80}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint80_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint80.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheUint80}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheuint80_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint80.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheUint80}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheuint80_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint80.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {any}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint80_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return takeFromExternrefTable0$1(ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheuint80_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheUint80}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint80_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint80.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheuint80_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheUint80}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint80_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint80.__wrap(ret[0]);\n  }\n}\nconst FheUint88Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheuint88_free(ptr >>> 0, 1));\nclass FheUint88 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheUint88.prototype);\n    obj.__wbg_ptr = ptr;\n    FheUint88Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheUint88Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheuint88_free(ptr, 0);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheUint88}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint88_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint88.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheUint88}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheuint88_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint88.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheUint88}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheuint88_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint88.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {any}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint88_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return takeFromExternrefTable0$1(ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheuint88_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheUint88}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint88_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint88.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheuint88_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheUint88}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint88_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint88.__wrap(ret[0]);\n  }\n}\nconst FheUint96Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_fheuint96_free(ptr >>> 0, 1));\nclass FheUint96 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(FheUint96.prototype);\n    obj.__wbg_ptr = ptr;\n    FheUint96Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    FheUint96Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_fheuint96_free(ptr, 0);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheClientKey} client_key\n   * @returns {FheUint96}\n   */\n  static encrypt_with_client_key(value, client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint96_encrypt_with_client_key(value, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint96.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfhePublicKey} public_key\n   * @returns {FheUint96}\n   */\n  static encrypt_with_public_key(value, public_key) {\n    _assertClass$1(public_key, TfhePublicKey);\n    const ret = wasm$1.fheuint96_encrypt_with_public_key(value, public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint96.__wrap(ret[0]);\n  }\n  /**\n   * @param {any} value\n   * @param {TfheCompressedPublicKey} compressed_public_key\n   * @returns {FheUint96}\n   */\n  static encrypt_with_compressed_public_key(value, compressed_public_key) {\n    _assertClass$1(compressed_public_key, TfheCompressedPublicKey);\n    const ret = wasm$1.fheuint96_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint96.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {any}\n   */\n  decrypt(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.fheuint96_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return takeFromExternrefTable0$1(ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.fheuint96_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {FheUint96}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint96_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint96.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.fheuint96_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {FheUint96}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.fheuint96_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return FheUint96.__wrap(ret[0]);\n  }\n}\nconst ProvenCompactCiphertextListFinalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_provencompactciphertextlist_free(ptr >>> 0, 1));\nclass ProvenCompactCiphertextList {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(ProvenCompactCiphertextList.prototype);\n    obj.__wbg_ptr = ptr;\n    ProvenCompactCiphertextListFinalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    ProvenCompactCiphertextListFinalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_provencompactciphertextlist_free(ptr, 0);\n  }\n  /**\n   * @param {TfheCompactPublicKey} public_key\n   * @returns {CompactCiphertextListBuilder}\n   */\n  static builder(public_key) {\n    _assertClass$1(public_key, TfheCompactPublicKey);\n    const ret = wasm$1.provencompactciphertextlist_builder(public_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return CompactCiphertextListBuilder.__wrap(ret[0]);\n  }\n  /**\n   * @returns {number}\n   */\n  len() {\n    const ret = wasm$1.compactciphertextlistexpander_len(this.__wbg_ptr);\n    return ret >>> 0;\n  }\n  /**\n   * @returns {boolean}\n   */\n  is_empty() {\n    const ret = wasm$1.compactciphertextlistexpander_is_empty(this.__wbg_ptr);\n    return ret !== 0;\n  }\n  /**\n   * @param {number} index\n   * @returns {FheTypes | undefined}\n   */\n  get_kind_of(index) {\n    const ret = wasm$1.provencompactciphertextlist_get_kind_of(this.__wbg_ptr, index);\n    return ret === 84 ? undefined : ret;\n  }\n  /**\n   * @param {CompactPkeCrs} crs\n   * @param {TfheCompactPublicKey} public_key\n   * @param {Uint8Array} metadata\n   * @returns {CompactCiphertextListExpander}\n   */\n  verify_and_expand(crs, public_key, metadata) {\n    _assertClass$1(crs, CompactPkeCrs);\n    _assertClass$1(public_key, TfheCompactPublicKey);\n    const ptr0 = passArray8ToWasm0$1(metadata, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.provencompactciphertextlist_verify_and_expand(this.__wbg_ptr, crs.__wbg_ptr, public_key.__wbg_ptr, ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return CompactCiphertextListExpander.__wrap(ret[0]);\n  }\n  /**\n   * @returns {CompactCiphertextListExpander}\n   */\n  expand_without_verification() {\n    const ret = wasm$1.provencompactciphertextlist_expand_without_verification(this.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return CompactCiphertextListExpander.__wrap(ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.provencompactciphertextlist_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {ProvenCompactCiphertextList}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.provencompactciphertextlist_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return ProvenCompactCiphertextList.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.provencompactciphertextlist_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {ProvenCompactCiphertextList}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.provencompactciphertextlist_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return ProvenCompactCiphertextList.__wrap(ret[0]);\n  }\n}\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_shortint_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_shortintciphertext_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_shortintclientkey_free(ptr >>> 0, 1));\nconst ShortintCompactPublicKeyEncryptionParametersFinalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_shortintcompactpublickeyencryptionparameters_free(ptr >>> 0, 1));\nclass ShortintCompactPublicKeyEncryptionParameters {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(ShortintCompactPublicKeyEncryptionParameters.prototype);\n    obj.__wbg_ptr = ptr;\n    ShortintCompactPublicKeyEncryptionParametersFinalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    ShortintCompactPublicKeyEncryptionParametersFinalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_shortintcompactpublickeyencryptionparameters_free(ptr, 0);\n  }\n  /**\n   * @param {ShortintCompactPublicKeyEncryptionParametersName} name\n   */\n  constructor(name) {\n    const ret = wasm$1.shortintcompactpublickeyencryptionparameters_new(name);\n    this.__wbg_ptr = ret >>> 0;\n    ShortintCompactPublicKeyEncryptionParametersFinalization.register(this, this.__wbg_ptr, this);\n    return this;\n  }\n  /**\n   * @param {number} encryption_lwe_dimension\n   * @param {ShortintNoiseDistribution} encryption_noise_distribution\n   * @param {bigint} message_modulus\n   * @param {bigint} carry_modulus\n   * @param {number} modulus_power_of_2_exponent\n   * @param {number} ks_base_log\n   * @param {number} ks_level\n   * @param {ShortintEncryptionKeyChoice} encryption_key_choice\n   * @returns {ShortintCompactPublicKeyEncryptionParameters}\n   */\n  static new_parameters(encryption_lwe_dimension, encryption_noise_distribution, message_modulus, carry_modulus, modulus_power_of_2_exponent, ks_base_log, ks_level, encryption_key_choice) {\n    _assertClass$1(encryption_noise_distribution, ShortintNoiseDistribution);\n    const ret = wasm$1.shortintcompactpublickeyencryptionparameters_new_parameters(encryption_lwe_dimension, encryption_noise_distribution.__wbg_ptr, message_modulus, carry_modulus, modulus_power_of_2_exponent, ks_base_log, ks_level, encryption_key_choice);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return ShortintCompactPublicKeyEncryptionParameters.__wrap(ret[0]);\n  }\n}\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_shortintcompressedciphertext_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_shortintcompressedpublickey_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_shortintcompressedserverkey_free(ptr >>> 0, 1));\nconst ShortintNoiseDistributionFinalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_shortintnoisedistribution_free(ptr >>> 0, 1));\nclass ShortintNoiseDistribution {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(ShortintNoiseDistribution.prototype);\n    obj.__wbg_ptr = ptr;\n    ShortintNoiseDistributionFinalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    ShortintNoiseDistributionFinalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_shortintnoisedistribution_free(ptr, 0);\n  }\n}\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_shortintparameters_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_shortintpublickey_free(ptr >>> 0, 1));\nconst TfheClientKeyFinalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_tfheclientkey_free(ptr >>> 0, 1));\nclass TfheClientKey {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(TfheClientKey.prototype);\n    obj.__wbg_ptr = ptr;\n    TfheClientKeyFinalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    TfheClientKeyFinalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_tfheclientkey_free(ptr, 0);\n  }\n  /**\n   * @param {TfheConfig} config\n   * @returns {TfheClientKey}\n   */\n  static generate(config) {\n    _assertClass$1(config, TfheConfig);\n    const ret = wasm$1.tfheclientkey_generate(config.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return TfheClientKey.__wrap(ret[0]);\n  }\n  /**\n   * @param {TfheConfig} config\n   * @param {any} seed\n   * @returns {TfheClientKey}\n   */\n  static generate_with_seed(config, seed) {\n    _assertClass$1(config, TfheConfig);\n    const ret = wasm$1.tfheclientkey_generate_with_seed(config.__wbg_ptr, seed);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return TfheClientKey.__wrap(ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.tfheclientkey_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {TfheClientKey}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.tfheclientkey_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return TfheClientKey.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.tfheclientkey_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {TfheClientKey}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.tfheclientkey_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return TfheClientKey.__wrap(ret[0]);\n  }\n}\nconst TfheCompactPublicKeyFinalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_tfhecompactpublickey_free(ptr >>> 0, 1));\nclass TfheCompactPublicKey {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(TfheCompactPublicKey.prototype);\n    obj.__wbg_ptr = ptr;\n    TfheCompactPublicKeyFinalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    TfheCompactPublicKeyFinalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_tfhecompactpublickey_free(ptr, 0);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {TfheCompactPublicKey}\n   */\n  static new(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.tfhecompactpublickey_new(client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return TfheCompactPublicKey.__wrap(ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.tfhecompactpublickey_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {TfheCompactPublicKey}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.tfhecompactpublickey_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return TfheCompactPublicKey.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.tfhecompactpublickey_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {TfheCompactPublicKey}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.tfhecompactpublickey_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return TfheCompactPublicKey.__wrap(ret[0]);\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @param {ShortintCompactPublicKeyEncryptionParameters} conformance_params\n   * @returns {TfheCompactPublicKey}\n   */\n  static safe_deserialize_conformant(buffer, serialized_size_limit, conformance_params) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    _assertClass$1(conformance_params, ShortintCompactPublicKeyEncryptionParameters);\n    const ret = wasm$1.tfhecompactpublickey_safe_deserialize_conformant(ptr0, len0, serialized_size_limit, conformance_params.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return TfheCompactPublicKey.__wrap(ret[0]);\n  }\n}\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_tfhecompressedcompactpublickey_free(ptr >>> 0, 1));\nconst TfheCompressedPublicKeyFinalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_tfhecompressedpublickey_free(ptr >>> 0, 1));\nclass TfheCompressedPublicKey {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(TfheCompressedPublicKey.prototype);\n    obj.__wbg_ptr = ptr;\n    TfheCompressedPublicKeyFinalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    TfheCompressedPublicKeyFinalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_tfhecompressedpublickey_free(ptr, 0);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {TfheCompressedPublicKey}\n   */\n  static new(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.tfhecompressedpublickey_new(client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return TfheCompressedPublicKey.__wrap(ret[0]);\n  }\n  /**\n   * @returns {TfhePublicKey}\n   */\n  decompress() {\n    const ret = wasm$1.tfhecompressedpublickey_decompress(this.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return TfhePublicKey.__wrap(ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.tfhecompressedpublickey_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {TfheCompressedPublicKey}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.tfhecompressedpublickey_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return TfheCompressedPublicKey.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.tfhecompressedpublickey_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {TfheCompressedPublicKey}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.tfhecompressedpublickey_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return TfheCompressedPublicKey.__wrap(ret[0]);\n  }\n}\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_tfhecompressedserverkey_free(ptr >>> 0, 1));\nconst TfheConfigFinalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_tfheconfig_free(ptr >>> 0, 1));\nclass TfheConfig {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(TfheConfig.prototype);\n    obj.__wbg_ptr = ptr;\n    TfheConfigFinalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    TfheConfigFinalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_tfheconfig_free(ptr, 0);\n  }\n}\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_tfheconfigbuilder_free(ptr >>> 0, 1));\nconst TfhePublicKeyFinalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_tfhepublickey_free(ptr >>> 0, 1));\nclass TfhePublicKey {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(TfhePublicKey.prototype);\n    obj.__wbg_ptr = ptr;\n    TfhePublicKeyFinalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    TfhePublicKeyFinalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_tfhepublickey_free(ptr, 0);\n  }\n  /**\n   * @param {TfheClientKey} client_key\n   * @returns {TfhePublicKey}\n   */\n  static new(client_key) {\n    _assertClass$1(client_key, TfheClientKey);\n    const ret = wasm$1.tfhepublickey_new(client_key.__wbg_ptr);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return TfhePublicKey.__wrap(ret[0]);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  serialize() {\n    const ret = wasm$1.tfhepublickey_serialize(this.__wbg_ptr);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @returns {TfhePublicKey}\n   */\n  static deserialize(buffer) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.tfhepublickey_deserialize(ptr0, len0);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return TfhePublicKey.__wrap(ret[0]);\n  }\n  /**\n   * @param {bigint} serialized_size_limit\n   * @returns {Uint8Array}\n   */\n  safe_serialize(serialized_size_limit) {\n    const ret = wasm$1.tfhepublickey_safe_serialize(this.__wbg_ptr, serialized_size_limit);\n    if (ret[3]) {\n      throw takeFromExternrefTable0$1(ret[2]);\n    }\n    var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();\n    wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} buffer\n   * @param {bigint} serialized_size_limit\n   * @returns {TfhePublicKey}\n   */\n  static safe_deserialize(buffer, serialized_size_limit) {\n    const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN$1;\n    const ret = wasm$1.tfhepublickey_safe_deserialize(ptr0, len0, serialized_size_limit);\n    if (ret[2]) {\n      throw takeFromExternrefTable0$1(ret[1]);\n    }\n    return TfhePublicKey.__wrap(ret[0]);\n  }\n}\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_tfheserverkey_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm$1.__wbg_tfhe_free(ptr >>> 0, 1));\nconst wbg_rayon_PoolBuilderFinalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm$1.__wbg_wbg_rayon_poolbuilder_free(ptr >>> 0, 1));\nclass wbg_rayon_PoolBuilder {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(wbg_rayon_PoolBuilder.prototype);\n    obj.__wbg_ptr = ptr;\n    wbg_rayon_PoolBuilderFinalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    wbg_rayon_PoolBuilderFinalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm$1.__wbg_wbg_rayon_poolbuilder_free(ptr, 0);\n  }\n  /**\n   * @returns {number}\n   */\n  numThreads() {\n    const ret = wasm$1.wbg_rayon_poolbuilder_numThreads(this.__wbg_ptr);\n    return ret >>> 0;\n  }\n  /**\n   * @returns {number}\n   */\n  receiver() {\n    const ret = wasm$1.wbg_rayon_poolbuilder_receiver(this.__wbg_ptr);\n    return ret >>> 0;\n  }\n  build() {\n    wasm$1.wbg_rayon_poolbuilder_build(this.__wbg_ptr);\n  }\n}\nfunction __wbg_load$1(_x5, _x6) {\n  return _wbg_load$.apply(this, arguments);\n}\nfunction _wbg_load$() {\n  _wbg_load$ = _asyncToGenerator(function* (module, imports) {\n    if (typeof Response === 'function' && module instanceof Response) {\n      if (typeof WebAssembly.instantiateStreaming === 'function') {\n        try {\n          return yield WebAssembly.instantiateStreaming(module, imports);\n        } catch (e) {\n          if (module.headers.get('Content-Type') != 'application/wasm') {\n            console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", e);\n          } else {\n            throw e;\n          }\n        }\n      }\n      const bytes = yield module.arrayBuffer();\n      return yield WebAssembly.instantiate(bytes, imports);\n    } else {\n      const instance = yield WebAssembly.instantiate(module, imports);\n      if (instance instanceof WebAssembly.Instance) {\n        return {\n          instance,\n          module\n        };\n      } else {\n        return instance;\n      }\n    }\n  });\n  return _wbg_load$.apply(this, arguments);\n}\nfunction __wbg_get_imports$1() {\n  const imports = {};\n  imports.wbg = {};\n  imports.wbg.__wbg_BigInt_470dd987b8190f8e = function (arg0) {\n    const ret = BigInt(arg0);\n    return ret;\n  };\n  imports.wbg.__wbg_BigInt_ddea6d2f55558acb = function () {\n    return handleError$1(function (arg0) {\n      const ret = BigInt(arg0);\n      return ret;\n    }, arguments);\n  };\n  imports.wbg.__wbg_buffer_609cc3eee51ed158 = function (arg0) {\n    const ret = arg0.buffer;\n    return ret;\n  };\n  imports.wbg.__wbg_call_672a4d21634d4a24 = function () {\n    return handleError$1(function (arg0, arg1) {\n      const ret = arg0.call(arg1);\n      return ret;\n    }, arguments);\n  };\n  imports.wbg.__wbg_call_7cccdd69e0791ae2 = function () {\n    return handleError$1(function (arg0, arg1, arg2) {\n      const ret = arg0.call(arg1, arg2);\n      return ret;\n    }, arguments);\n  };\n  imports.wbg.__wbg_crypto_574e78ad8b13b65f = function (arg0) {\n    const ret = arg0.crypto;\n    return ret;\n  };\n  imports.wbg.__wbg_error_7534b8e9a36f1ab4 = function (arg0, arg1) {\n    let deferred0_0;\n    let deferred0_1;\n    try {\n      deferred0_0 = arg0;\n      deferred0_1 = arg1;\n      console.error(getStringFromWasm0$1(arg0, arg1));\n    } finally {\n      wasm$1.__wbindgen_free(deferred0_0, deferred0_1, 1);\n    }\n  };\n  imports.wbg.__wbg_getRandomValues_b8f5dbd5f3995a9e = function () {\n    return handleError$1(function (arg0, arg1) {\n      arg0.getRandomValues(arg1);\n    }, arguments);\n  };\n  imports.wbg.__wbg_getTime_46267b1c24877e30 = function (arg0) {\n    const ret = arg0.getTime();\n    return ret;\n  };\n  imports.wbg.__wbg_instanceof_Window_def73ea0955fc569 = function (arg0) {\n    let result;\n    try {\n      result = arg0 instanceof Window;\n    } catch (_) {\n      result = false;\n    }\n    const ret = result;\n    return ret;\n  };\n  imports.wbg.__wbg_msCrypto_a61aeb35a24c1329 = function (arg0) {\n    const ret = arg0.msCrypto;\n    return ret;\n  };\n  imports.wbg.__wbg_new0_f788a2397c7ca929 = function () {\n    const ret = new Date();\n    return ret;\n  };\n  imports.wbg.__wbg_new_8a6f238a6ece86ea = function () {\n    const ret = new Error();\n    return ret;\n  };\n  imports.wbg.__wbg_new_a12002a7f91c75be = function (arg0) {\n    const ret = new Uint8Array(arg0);\n    return ret;\n  };\n  imports.wbg.__wbg_newnoargs_105ed471475aaf50 = function (arg0, arg1) {\n    const ret = new Function(getStringFromWasm0$1(arg0, arg1));\n    return ret;\n  };\n  imports.wbg.__wbg_newwithbyteoffsetandlength_d97e637ebe145a9a = function (arg0, arg1, arg2) {\n    const ret = new Uint8Array(arg0, arg1 >>> 0, arg2 >>> 0);\n    return ret;\n  };\n  imports.wbg.__wbg_newwithlength_a381634e90c276d4 = function (arg0) {\n    const ret = new Uint8Array(arg0 >>> 0);\n    return ret;\n  };\n  imports.wbg.__wbg_node_905d3e251edff8a2 = function (arg0) {\n    const ret = arg0.node;\n    return ret;\n  };\n  imports.wbg.__wbg_process_dc0fbacc7c1c06f7 = function (arg0) {\n    const ret = arg0.process;\n    return ret;\n  };\n  imports.wbg.__wbg_randomFillSync_ac0988aba3254290 = function () {\n    return handleError$1(function (arg0, arg1) {\n      arg0.randomFillSync(arg1);\n    }, arguments);\n  };\n  imports.wbg.__wbg_require_60cc747a6bc5215a = function () {\n    return handleError$1(function () {\n      const ret = module.require;\n      return ret;\n    }, arguments);\n  };\n  imports.wbg.__wbg_set_65595bdd868b3009 = function (arg0, arg1, arg2) {\n    arg0.set(arg1, arg2 >>> 0);\n  };\n  imports.wbg.__wbg_stack_0ed75d68575b0f3c = function (arg0, arg1) {\n    const ret = arg1.stack;\n    const ptr1 = passStringToWasm0$1(ret, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);\n    const len1 = WASM_VECTOR_LEN$1;\n    getDataViewMemory0$1().setInt32(arg0 + 4 * 1, len1, true);\n    getDataViewMemory0$1().setInt32(arg0 + 4 * 0, ptr1, true);\n  };\n  imports.wbg.__wbg_startWorkers_2ca11761e08ff5d5 = function (arg0, arg1, arg2) {\n    const ret = startWorkers(arg0, arg1, wbg_rayon_PoolBuilder.__wrap(arg2));\n    return ret;\n  };\n  imports.wbg.__wbg_static_accessor_GLOBAL_88a902d13a557d07 = function () {\n    const ret = typeof global$1 === 'undefined' ? null : global$1;\n    return isLikeNone$1(ret) ? 0 : addToExternrefTable0$1(ret);\n  };\n  imports.wbg.__wbg_static_accessor_GLOBAL_THIS_56578be7e9f832b0 = function () {\n    const ret = typeof globalThis === 'undefined' ? null : globalThis;\n    return isLikeNone$1(ret) ? 0 : addToExternrefTable0$1(ret);\n  };\n  imports.wbg.__wbg_static_accessor_SELF_37c5d418e4bf5819 = function () {\n    const ret = typeof self === 'undefined' ? null : self;\n    return isLikeNone$1(ret) ? 0 : addToExternrefTable0$1(ret);\n  };\n  imports.wbg.__wbg_static_accessor_WINDOW_5de37043a91a9c40 = function () {\n    const ret = typeof window === 'undefined' ? null : window;\n    return isLikeNone$1(ret) ? 0 : addToExternrefTable0$1(ret);\n  };\n  imports.wbg.__wbg_subarray_aa9065fa9dc5df96 = function (arg0, arg1, arg2) {\n    const ret = arg0.subarray(arg1 >>> 0, arg2 >>> 0);\n    return ret;\n  };\n  imports.wbg.__wbg_toString_2f76f493957b63da = function (arg0, arg1, arg2) {\n    const ret = arg1.toString(arg2);\n    const ptr1 = passStringToWasm0$1(ret, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);\n    const len1 = WASM_VECTOR_LEN$1;\n    getDataViewMemory0$1().setInt32(arg0 + 4 * 1, len1, true);\n    getDataViewMemory0$1().setInt32(arg0 + 4 * 0, ptr1, true);\n  };\n  imports.wbg.__wbg_toString_c813bbd34d063839 = function (arg0) {\n    const ret = arg0.toString();\n    return ret;\n  };\n  imports.wbg.__wbg_versions_c01dfd4722a88165 = function (arg0) {\n    const ret = arg0.versions;\n    return ret;\n  };\n  imports.wbg.__wbindgen_bigint_from_i128 = function (arg0, arg1) {\n    const ret = arg0 << BigInt(64) | BigInt.asUintN(64, arg1);\n    return ret;\n  };\n  imports.wbg.__wbindgen_bigint_from_i64 = function (arg0) {\n    const ret = arg0;\n    return ret;\n  };\n  imports.wbg.__wbindgen_bigint_from_u128 = function (arg0, arg1) {\n    const ret = BigInt.asUintN(64, arg0) << BigInt(64) | BigInt.asUintN(64, arg1);\n    return ret;\n  };\n  imports.wbg.__wbindgen_bigint_from_u64 = function (arg0) {\n    const ret = BigInt.asUintN(64, arg0);\n    return ret;\n  };\n  imports.wbg.__wbindgen_bigint_get_as_i64 = function (arg0, arg1) {\n    const v = arg1;\n    const ret = typeof v === 'bigint' ? v : undefined;\n    getDataViewMemory0$1().setBigInt64(arg0 + 8 * 1, isLikeNone$1(ret) ? BigInt(0) : ret, true);\n    getDataViewMemory0$1().setInt32(arg0 + 4 * 0, !isLikeNone$1(ret), true);\n  };\n  imports.wbg.__wbindgen_bit_and = function (arg0, arg1) {\n    const ret = arg0 & arg1;\n    return ret;\n  };\n  imports.wbg.__wbindgen_bit_or = function (arg0, arg1) {\n    const ret = arg0 | arg1;\n    return ret;\n  };\n  imports.wbg.__wbindgen_debug_string = function (arg0, arg1) {\n    const ret = debugString$1(arg1);\n    const ptr1 = passStringToWasm0$1(ret, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);\n    const len1 = WASM_VECTOR_LEN$1;\n    getDataViewMemory0$1().setInt32(arg0 + 4 * 1, len1, true);\n    getDataViewMemory0$1().setInt32(arg0 + 4 * 0, ptr1, true);\n  };\n  imports.wbg.__wbindgen_error_new = function (arg0, arg1) {\n    const ret = new Error(getStringFromWasm0$1(arg0, arg1));\n    return ret;\n  };\n  imports.wbg.__wbindgen_init_externref_table = function () {\n    const table = wasm$1.__wbindgen_export_2;\n    const offset = table.grow(4);\n    table.set(0, undefined);\n    table.set(offset + 0, undefined);\n    table.set(offset + 1, null);\n    table.set(offset + 2, true);\n    table.set(offset + 3, false);\n  };\n  imports.wbg.__wbindgen_is_function = function (arg0) {\n    const ret = typeof arg0 === 'function';\n    return ret;\n  };\n  imports.wbg.__wbindgen_is_object = function (arg0) {\n    const val = arg0;\n    const ret = typeof val === 'object' && val !== null;\n    return ret;\n  };\n  imports.wbg.__wbindgen_is_string = function (arg0) {\n    const ret = typeof arg0 === 'string';\n    return ret;\n  };\n  imports.wbg.__wbindgen_is_undefined = function (arg0) {\n    const ret = arg0 === undefined;\n    return ret;\n  };\n  imports.wbg.__wbindgen_jsval_eq = function (arg0, arg1) {\n    const ret = arg0 === arg1;\n    return ret;\n  };\n  imports.wbg.__wbindgen_lt = function (arg0, arg1) {\n    const ret = arg0 < arg1;\n    return ret;\n  };\n  imports.wbg.__wbindgen_memory = function () {\n    const ret = wasm$1.memory;\n    return ret;\n  };\n  imports.wbg.__wbindgen_module = function () {\n    const ret = __wbg_init$1.__wbindgen_wasm_module;\n    return ret;\n  };\n  imports.wbg.__wbindgen_neg = function (arg0) {\n    const ret = -arg0;\n    return ret;\n  };\n  imports.wbg.__wbindgen_number_new = function (arg0) {\n    const ret = arg0;\n    return ret;\n  };\n  imports.wbg.__wbindgen_shl = function (arg0, arg1) {\n    const ret = arg0 << arg1;\n    return ret;\n  };\n  imports.wbg.__wbindgen_shr = function (arg0, arg1) {\n    const ret = arg0 >> arg1;\n    return ret;\n  };\n  imports.wbg.__wbindgen_string_get = function (arg0, arg1) {\n    const obj = arg1;\n    const ret = typeof obj === 'string' ? obj : undefined;\n    var ptr1 = isLikeNone$1(ret) ? 0 : passStringToWasm0$1(ret, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);\n    var len1 = WASM_VECTOR_LEN$1;\n    getDataViewMemory0$1().setInt32(arg0 + 4 * 1, len1, true);\n    getDataViewMemory0$1().setInt32(arg0 + 4 * 0, ptr1, true);\n  };\n  imports.wbg.__wbindgen_string_new = function (arg0, arg1) {\n    const ret = getStringFromWasm0$1(arg0, arg1);\n    return ret;\n  };\n  imports.wbg.__wbindgen_throw = function (arg0, arg1) {\n    throw new Error(getStringFromWasm0$1(arg0, arg1));\n  };\n  return imports;\n}\nfunction __wbg_init_memory(imports, memory) {\n  imports.wbg.memory = memory || new WebAssembly.Memory({\n    initial: 21,\n    maximum: 16384,\n    shared: true\n  });\n}\nfunction __wbg_finalize_init$1(instance, module, thread_stack_size) {\n  wasm$1 = instance.exports;\n  __wbg_init$1.__wbindgen_wasm_module = module;\n  cachedDataViewMemory0$1 = null;\n  cachedUint8ArrayMemory0$1 = null;\n  if (typeof thread_stack_size !== 'undefined' && (typeof thread_stack_size !== 'number' || thread_stack_size === 0 || thread_stack_size % 65536 !== 0)) {\n    throw 'invalid stack size';\n  }\n  wasm$1.__wbindgen_start(thread_stack_size);\n  return wasm$1;\n}\nfunction __wbg_init$1(_x7, _x8) {\n  return _wbg_init$.apply(this, arguments);\n}\nfunction _wbg_init$() {\n  _wbg_init$ = _asyncToGenerator(function* (module_or_path, memory) {\n    if (wasm$1 !== undefined) return wasm$1;\n    let thread_stack_size;\n    if (typeof module_or_path !== 'undefined') {\n      if (Object.getPrototypeOf(module_or_path) === Object.prototype) {\n        ({\n          module_or_path,\n          memory,\n          thread_stack_size\n        } = module_or_path);\n      } else {\n        console.warn('using deprecated parameters for the initialization function; pass a single object instead');\n      }\n    }\n    if (typeof module_or_path === 'undefined') {\n      module_or_path = new URL('tfhe_bg.wasm', import.meta.url);\n    }\n    const imports = __wbg_get_imports$1();\n    if (typeof module_or_path === 'string' || typeof Request === 'function' && module_or_path instanceof Request || typeof URL === 'function' && module_or_path instanceof URL) {\n      module_or_path = fetch(module_or_path);\n    }\n    __wbg_init_memory(imports, memory);\n    const {\n      instance,\n      module\n    } = yield __wbg_load$1(yield module_or_path, imports);\n    return __wbg_finalize_init$1(instance, module, thread_stack_size);\n  });\n  return _wbg_init$.apply(this, arguments);\n}\nvar tfhe = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  CompactCiphertextList: CompactCiphertextList,\n  CompactCiphertextListBuilder: CompactCiphertextListBuilder,\n  CompactCiphertextListExpander: CompactCiphertextListExpander,\n  CompactPkeCrs: CompactPkeCrs,\n  FheBool: FheBool,\n  FheInt10: FheInt10,\n  FheInt1024: FheInt1024,\n  FheInt104: FheInt104,\n  FheInt112: FheInt112,\n  FheInt12: FheInt12,\n  FheInt120: FheInt120,\n  FheInt128: FheInt128,\n  FheInt136: FheInt136,\n  FheInt14: FheInt14,\n  FheInt144: FheInt144,\n  FheInt152: FheInt152,\n  FheInt16: FheInt16,\n  FheInt160: FheInt160,\n  FheInt168: FheInt168,\n  FheInt176: FheInt176,\n  FheInt184: FheInt184,\n  FheInt192: FheInt192,\n  FheInt2: FheInt2,\n  FheInt200: FheInt200,\n  FheInt2048: FheInt2048,\n  FheInt208: FheInt208,\n  FheInt216: FheInt216,\n  FheInt224: FheInt224,\n  FheInt232: FheInt232,\n  FheInt24: FheInt24,\n  FheInt240: FheInt240,\n  FheInt248: FheInt248,\n  FheInt256: FheInt256,\n  FheInt32: FheInt32,\n  FheInt4: FheInt4,\n  FheInt40: FheInt40,\n  FheInt48: FheInt48,\n  FheInt512: FheInt512,\n  FheInt56: FheInt56,\n  FheInt6: FheInt6,\n  FheInt64: FheInt64,\n  FheInt72: FheInt72,\n  FheInt8: FheInt8,\n  FheInt80: FheInt80,\n  FheInt88: FheInt88,\n  FheInt96: FheInt96,\n  FheUint10: FheUint10,\n  FheUint1024: FheUint1024,\n  FheUint104: FheUint104,\n  FheUint112: FheUint112,\n  FheUint12: FheUint12,\n  FheUint120: FheUint120,\n  FheUint128: FheUint128,\n  FheUint136: FheUint136,\n  FheUint14: FheUint14,\n  FheUint144: FheUint144,\n  FheUint152: FheUint152,\n  FheUint16: FheUint16,\n  FheUint160: FheUint160,\n  FheUint168: FheUint168,\n  FheUint176: FheUint176,\n  FheUint184: FheUint184,\n  FheUint192: FheUint192,\n  FheUint2: FheUint2,\n  FheUint200: FheUint200,\n  FheUint2048: FheUint2048,\n  FheUint208: FheUint208,\n  FheUint216: FheUint216,\n  FheUint224: FheUint224,\n  FheUint232: FheUint232,\n  FheUint24: FheUint24,\n  FheUint240: FheUint240,\n  FheUint248: FheUint248,\n  FheUint256: FheUint256,\n  FheUint32: FheUint32,\n  FheUint4: FheUint4,\n  FheUint40: FheUint40,\n  FheUint48: FheUint48,\n  FheUint512: FheUint512,\n  FheUint56: FheUint56,\n  FheUint6: FheUint6,\n  FheUint64: FheUint64,\n  FheUint72: FheUint72,\n  FheUint8: FheUint8,\n  FheUint80: FheUint80,\n  FheUint88: FheUint88,\n  FheUint96: FheUint96,\n  ProvenCompactCiphertextList: ProvenCompactCiphertextList,\n  ShortintCompactPublicKeyEncryptionParameters: ShortintCompactPublicKeyEncryptionParameters,\n  ShortintNoiseDistribution: ShortintNoiseDistribution,\n  TfheClientKey: TfheClientKey,\n  TfheCompactPublicKey: TfheCompactPublicKey,\n  TfheCompressedPublicKey: TfheCompressedPublicKey,\n  TfheConfig: TfheConfig,\n  TfhePublicKey: TfhePublicKey,\n  ZkComputeLoad: ZkComputeLoad,\n  default: __wbg_init$1,\n  initThreadPool: initThreadPool,\n  init_panic_hook: init_panic_hook,\n  wbg_rayon_PoolBuilder: wbg_rayon_PoolBuilder,\n  wbg_rayon_start_worker: wbg_rayon_start_worker\n});\nlet wasm;\nlet WASM_VECTOR_LEN = 0;\nlet cachedUint8ArrayMemory0 = null;\nfunction getUint8ArrayMemory0() {\n  if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {\n    cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);\n  }\n  return cachedUint8ArrayMemory0;\n}\nconst cachedTextEncoder = typeof TextEncoder !== 'undefined' ? new TextEncoder('utf-8') : {\n  encode: () => {\n    throw Error('TextEncoder not available');\n  }\n};\nconst encodeString = typeof cachedTextEncoder.encodeInto === 'function' ? function (arg, view) {\n  return cachedTextEncoder.encodeInto(arg, view);\n} : function (arg, view) {\n  const buf = cachedTextEncoder.encode(arg);\n  view.set(buf);\n  return {\n    read: arg.length,\n    written: buf.length\n  };\n};\nfunction passStringToWasm0(arg, malloc, realloc) {\n  if (realloc === undefined) {\n    const buf = cachedTextEncoder.encode(arg);\n    const ptr = malloc(buf.length, 1) >>> 0;\n    getUint8ArrayMemory0().subarray(ptr, ptr + buf.length).set(buf);\n    WASM_VECTOR_LEN = buf.length;\n    return ptr;\n  }\n  let len = arg.length;\n  let ptr = malloc(len, 1) >>> 0;\n  const mem = getUint8ArrayMemory0();\n  let offset = 0;\n  for (; offset < len; offset++) {\n    const code = arg.charCodeAt(offset);\n    if (code > 0x7F) break;\n    mem[ptr + offset] = code;\n  }\n  if (offset !== len) {\n    if (offset !== 0) {\n      arg = arg.slice(offset);\n    }\n    ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;\n    const view = getUint8ArrayMemory0().subarray(ptr + offset, ptr + len);\n    const ret = encodeString(arg, view);\n    offset += ret.written;\n    ptr = realloc(ptr, len, offset, 1) >>> 0;\n  }\n  WASM_VECTOR_LEN = offset;\n  return ptr;\n}\nlet cachedDataViewMemory0 = null;\nfunction getDataViewMemory0() {\n  if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || cachedDataViewMemory0.buffer.detached === undefined && cachedDataViewMemory0.buffer !== wasm.memory.buffer) {\n    cachedDataViewMemory0 = new DataView(wasm.memory.buffer);\n  }\n  return cachedDataViewMemory0;\n}\nfunction addToExternrefTable0(obj) {\n  const idx = wasm.__externref_table_alloc();\n  wasm.__wbindgen_export_4.set(idx, obj);\n  return idx;\n}\nfunction handleError(f, args) {\n  try {\n    return f.apply(this, args);\n  } catch (e) {\n    const idx = addToExternrefTable0(e);\n    wasm.__wbindgen_exn_store(idx);\n  }\n}\nconst cachedTextDecoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-8', {\n  ignoreBOM: true,\n  fatal: true\n}) : {\n  decode: () => {\n    throw Error('TextDecoder not available');\n  }\n};\nif (typeof TextDecoder !== 'undefined') {\n  cachedTextDecoder.decode();\n}\nfunction getStringFromWasm0(ptr, len) {\n  ptr = ptr >>> 0;\n  return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));\n}\nfunction isLikeNone(x) {\n  return x === undefined || x === null;\n}\nfunction debugString(val) {\n  // primitive types\n  const type = typeof val;\n  if (type == 'number' || type == 'boolean' || val == null) {\n    return `${val}`;\n  }\n  if (type == 'string') {\n    return `\"${val}\"`;\n  }\n  if (type == 'symbol') {\n    const description = val.description;\n    if (description == null) {\n      return 'Symbol';\n    } else {\n      return `Symbol(${description})`;\n    }\n  }\n  if (type == 'function') {\n    const name = val.name;\n    if (typeof name == 'string' && name.length > 0) {\n      return `Function(${name})`;\n    } else {\n      return 'Function';\n    }\n  }\n  // objects\n  if (Array.isArray(val)) {\n    const length = val.length;\n    let debug = '[';\n    if (length > 0) {\n      debug += debugString(val[0]);\n    }\n    for (let i = 1; i < length; i++) {\n      debug += ', ' + debugString(val[i]);\n    }\n    debug += ']';\n    return debug;\n  }\n  // Test for built-in\n  const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val));\n  let className;\n  if (builtInMatches && builtInMatches.length > 1) {\n    className = builtInMatches[1];\n  } else {\n    // Failed to match the standard '[object ClassName]'\n    return toString.call(val);\n  }\n  if (className == 'Object') {\n    // we're a user defined class or Object\n    // JSON.stringify avoids problems with cycles, and is generally much\n    // easier than looping through ownProperties of `val`.\n    try {\n      return 'Object(' + JSON.stringify(val) + ')';\n    } catch (_) {\n      return 'Object';\n    }\n  }\n  // errors\n  if (val instanceof Error) {\n    return `${val.name}: ${val.message}\\n${val.stack}`;\n  }\n  // TODO we could test for more things here, like `Set`s and `Map`s.\n  return className;\n}\nfunction _assertClass(instance, klass) {\n  if (!(instance instanceof klass)) {\n    throw new Error(`expected instance of ${klass.name}`);\n  }\n}\nfunction getArrayU8FromWasm0(ptr, len) {\n  ptr = ptr >>> 0;\n  return getUint8ArrayMemory0().subarray(ptr / 1, ptr / 1 + len);\n}\nfunction passArray8ToWasm0(arg, malloc) {\n  const ptr = malloc(arg.length * 1, 1) >>> 0;\n  getUint8ArrayMemory0().set(arg, ptr / 1);\n  WASM_VECTOR_LEN = arg.length;\n  return ptr;\n}\nfunction takeFromExternrefTable0(idx) {\n  const value = wasm.__wbindgen_export_4.get(idx);\n  wasm.__externref_table_dealloc(idx);\n  return value;\n}\n\n/**\n * Create a new [ServerIdAddr] structure that holds an ID and an address\n * which must be a valid EIP-55 address, notably prefixed with \"0x\".\n * @param {number} id\n * @param {string} addr\n * @returns {ServerIdAddr}\n */\nfunction new_server_id_addr(id, addr) {\n  const ptr0 = passStringToWasm0(addr, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n  const len0 = WASM_VECTOR_LEN;\n  const ret = wasm.new_server_id_addr(id, ptr0, len0);\n  if (ret[2]) {\n    throw takeFromExternrefTable0(ret[1]);\n  }\n  return ServerIdAddr.__wrap(ret[0]);\n}\nfunction passArrayJsValueToWasm0(array, malloc) {\n  const ptr = malloc(array.length * 4, 4) >>> 0;\n  for (let i = 0; i < array.length; i++) {\n    const add = addToExternrefTable0(array[i]);\n    getDataViewMemory0().setUint32(ptr + 4 * i, add, true);\n  }\n  WASM_VECTOR_LEN = array.length;\n  return ptr;\n}\n/**\n * Instantiate a new client.\n *\n * * `server_addrs` - a list of KMS server ID with EIP-55 addresses,\n * the elements in the list can be created using [new_server_id_addr].\n *\n * * `client_address_hex` - the client (wallet) address in hex,\n * must be prefixed with \"0x\".\n *\n * * `fhe_parameter` - the parameter choice, which can be either `\"test\"` or `\"default\"`.\n * The \"default\" parameter choice is selected if no matching string is found.\n * @param {ServerIdAddr[]} server_addrs\n * @param {string} client_address_hex\n * @param {string} fhe_parameter\n * @returns {Client}\n */\nfunction new_client(server_addrs, client_address_hex, fhe_parameter) {\n  const ptr0 = passArrayJsValueToWasm0(server_addrs, wasm.__wbindgen_malloc);\n  const len0 = WASM_VECTOR_LEN;\n  const ptr1 = passStringToWasm0(client_address_hex, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n  const len1 = WASM_VECTOR_LEN;\n  const ptr2 = passStringToWasm0(fhe_parameter, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n  const len2 = WASM_VECTOR_LEN;\n  const ret = wasm.new_client(ptr0, len0, ptr1, len1, ptr2, len2);\n  if (ret[2]) {\n    throw takeFromExternrefTable0(ret[1]);\n  }\n  return Client.__wrap(ret[0]);\n}\nfunction getArrayJsValueFromWasm0(ptr, len) {\n  ptr = ptr >>> 0;\n  const mem = getDataViewMemory0();\n  const result = [];\n  for (let i = ptr; i < ptr + 4 * len; i += 4) {\n    result.push(wasm.__wbindgen_export_4.get(mem.getUint32(i, true)));\n  }\n  wasm.__externref_drop_slice(ptr, len);\n  return result;\n}\n\n/**\n * @returns {PrivateEncKeyMlKem512}\n */\nfunction ml_kem_pke_keygen() {\n  const ret = wasm.ml_kem_pke_keygen();\n  return PrivateEncKeyMlKem512.__wrap(ret);\n}\n\n/**\n * @param {PrivateEncKeyMlKem512} sk\n * @returns {PublicEncKeyMlKem512}\n */\nfunction ml_kem_pke_get_pk(sk) {\n  _assertClass(sk, PrivateEncKeyMlKem512);\n  const ret = wasm.ml_kem_pke_get_pk(sk.__wbg_ptr);\n  return PublicEncKeyMlKem512.__wrap(ret);\n}\n\n/**\n * @param {PublicEncKeyMlKem512} pk\n * @returns {Uint8Array}\n */\nfunction ml_kem_pke_pk_to_u8vec(pk) {\n  _assertClass(pk, PublicEncKeyMlKem512);\n  const ret = wasm.ml_kem_pke_pk_to_u8vec(pk.__wbg_ptr);\n  if (ret[3]) {\n    throw takeFromExternrefTable0(ret[2]);\n  }\n  var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n  wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n  return v1;\n}\n\n/**\n * @param {PrivateEncKeyMlKem512} sk\n * @returns {Uint8Array}\n */\nfunction ml_kem_pke_sk_to_u8vec(sk) {\n  _assertClass(sk, PrivateEncKeyMlKem512);\n  const ret = wasm.ml_kem_pke_sk_to_u8vec(sk.__wbg_ptr);\n  if (ret[3]) {\n    throw takeFromExternrefTable0(ret[2]);\n  }\n  var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n  wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n  return v1;\n}\n\n/**\n * @param {Uint8Array} v\n * @returns {PublicEncKeyMlKem512}\n */\nfunction u8vec_to_ml_kem_pke_pk(v) {\n  const ptr0 = passArray8ToWasm0(v, wasm.__wbindgen_malloc);\n  const len0 = WASM_VECTOR_LEN;\n  const ret = wasm.u8vec_to_ml_kem_pke_pk(ptr0, len0);\n  if (ret[2]) {\n    throw takeFromExternrefTable0(ret[1]);\n  }\n  return PublicEncKeyMlKem512.__wrap(ret[0]);\n}\n\n/**\n * @param {Uint8Array} v\n * @returns {PrivateEncKeyMlKem512}\n */\nfunction u8vec_to_ml_kem_pke_sk(v) {\n  const ptr0 = passArray8ToWasm0(v, wasm.__wbindgen_malloc);\n  const len0 = WASM_VECTOR_LEN;\n  const ret = wasm.u8vec_to_ml_kem_pke_sk(ptr0, len0);\n  if (ret[2]) {\n    throw takeFromExternrefTable0(ret[1]);\n  }\n  return PrivateEncKeyMlKem512.__wrap(ret[0]);\n}\n\n/**\n * Process the user_decryption response from JavaScript objects.\n * The returned result is a byte array representing a plaintext of any length,\n * postprocessing is returned to turn it into an integer.\n *\n * * `client` - client that wants to perform user_decryption.\n *\n * * `request` - the initial user_decryption request JS object.\n * It can be set to null if `verify` is false.\n * Otherwise the caller needs to give the following JS object.\n * Note that `client_address` and `eip712_verifying_contract` follow EIP-55.\n * The signature field is not needed.\n * ```\n * {\n *   signature: undefined,\n *   client_address: '0x17853A630aAe15AED549B2B874de08B73C0F59c5',\n *   enc_key: '2000000000000000df2fcacb774f03187f3802a27259f45c06d33cefa68d9c53426b15ad531aa822',\n *   ciphertext_handles: [ '0748b542afe2353c86cb707e3d21044b0be1fd18efc7cbaa6a415af055bfb358' ]\n *   eip712_verifying_contract: '0x66f9664f97F2b50F62D13eA064982f936dE76657'\n * }\n * ```\n *\n * * `eip712_domain` - the EIP-712 domain JS object.\n * It can be set to null if `verify` is false.\n * Otherwise the caller needs to give the following JS object.\n * Note that `salt` is optional and `verifying_contract` follows EIP-55,\n * additionally, `chain_id` is an array of u8.\n * ```\n * {\n *   name: 'Authorization token',\n *   version: '1',\n *   chain_id: [\n *     70, 31, 0, 0, 0, 0, 0, 0, 0,\n *      0,  0, 0, 0, 0, 0, 0, 0, 0,\n *      0,  0, 0, 0, 0, 0, 0, 0, 0,\n *      0,  0, 0, 0, 0\n *   ],\n *   verifying_contract: '0x66f9664f97F2b50F62D13eA064982f936dE76657',\n *   salt: []\n * }\n * ```\n *\n * * `agg_resp` - the response JS object from the gateway.\n * It has two fields like so, both are hex encoded byte arrays.\n * ```\n * [\n *   {\n *     signature: '69e7e040cab157aa819015b321c012dccb1545ffefd325b359b492653f0347517e28e66c572cdc299e259024329859ff9fcb0096e1ce072af0b6e1ca1fe25ec6',\n *     payload: '0100000029...',\n *     extra_data: '01234...',\n *   }\n * ]\n * ```\n *\n * * `enc_pk` - The ephemeral public key.\n *\n * * `enc_sk` - The ephemeral secret key.\n *\n * * `verify` - Whether to perform signature verification for the response.\n * It is insecure if `verify = false`!\n * @param {Client} client\n * @param {any} request\n * @param {any} eip712_domain\n * @param {any} agg_resp\n * @param {PublicEncKeyMlKem512} enc_pk\n * @param {PrivateEncKeyMlKem512} enc_sk\n * @param {boolean} verify\n * @returns {TypedPlaintext[]}\n */\nfunction process_user_decryption_resp_from_js(client, request, eip712_domain, agg_resp, enc_pk, enc_sk, verify) {\n  _assertClass(client, Client);\n  _assertClass(enc_pk, PublicEncKeyMlKem512);\n  _assertClass(enc_sk, PrivateEncKeyMlKem512);\n  const ret = wasm.process_user_decryption_resp_from_js(client.__wbg_ptr, request, eip712_domain, agg_resp, enc_pk.__wbg_ptr, enc_sk.__wbg_ptr, verify);\n  if (ret[3]) {\n    throw takeFromExternrefTable0(ret[2]);\n  }\n  var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();\n  wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);\n  return v1;\n}\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm.__wbg_ciphertexthandle_free(ptr >>> 0, 1));\nconst ClientFinalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm.__wbg_client_free(ptr >>> 0, 1));\n/**\n * Core Client\n *\n * Simple client to interact with the KMS servers. This can be seen as a proof-of-concept\n * and reference code for validating the KMS. The logic supplied by the client will be\n * distributed across the aggregator/proxy and smart contracts.\n */\nclass Client {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(Client.prototype);\n    obj.__wbg_ptr = ptr;\n    ClientFinalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    ClientFinalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm.__wbg_client_free(ptr, 0);\n  }\n}\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm.__wbg_eip712domainmsg_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm.__wbg_parseduserdecryptionrequest_free(ptr >>> 0, 1));\nconst PrivateEncKeyMlKem512Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm.__wbg_privateenckeymlkem512_free(ptr >>> 0, 1));\nclass PrivateEncKeyMlKem512 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(PrivateEncKeyMlKem512.prototype);\n    obj.__wbg_ptr = ptr;\n    PrivateEncKeyMlKem512Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    PrivateEncKeyMlKem512Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm.__wbg_privateenckeymlkem512_free(ptr, 0);\n  }\n}\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm.__wbg_privatesigkey_free(ptr >>> 0, 1));\nconst PublicEncKeyMlKem512Finalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm.__wbg_publicenckeymlkem512_free(ptr >>> 0, 1));\nclass PublicEncKeyMlKem512 {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(PublicEncKeyMlKem512.prototype);\n    obj.__wbg_ptr = ptr;\n    PublicEncKeyMlKem512Finalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    PublicEncKeyMlKem512Finalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm.__wbg_publicenckeymlkem512_free(ptr, 0);\n  }\n}\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm.__wbg_publicsigkey_free(ptr >>> 0, 1));\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm.__wbg_requestid_free(ptr >>> 0, 1));\nconst ServerIdAddrFinalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm.__wbg_serveridaddr_free(ptr >>> 0, 1));\nclass ServerIdAddr {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(ServerIdAddr.prototype);\n    obj.__wbg_ptr = ptr;\n    ServerIdAddrFinalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  static __unwrap(jsValue) {\n    if (!(jsValue instanceof ServerIdAddr)) {\n      return 0;\n    }\n    return jsValue.__destroy_into_raw();\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    ServerIdAddrFinalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm.__wbg_serveridaddr_free(ptr, 0);\n  }\n}\nconst TypedCiphertextFinalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm.__wbg_typedciphertext_free(ptr >>> 0, 1));\nclass TypedCiphertext {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(TypedCiphertext.prototype);\n    obj.__wbg_ptr = ptr;\n    TypedCiphertextFinalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  static __unwrap(jsValue) {\n    if (!(jsValue instanceof TypedCiphertext)) {\n      return 0;\n    }\n    return jsValue.__destroy_into_raw();\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    TypedCiphertextFinalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm.__wbg_typedciphertext_free(ptr, 0);\n  }\n  /**\n   * The actual ciphertext to decrypt, taken directly from fhevm.\n   * @returns {Uint8Array}\n   */\n  get ciphertext() {\n    const ret = wasm.__wbg_get_typedciphertext_ciphertext(this.__wbg_ptr);\n    var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * The actual ciphertext to decrypt, taken directly from fhevm.\n   * @param {Uint8Array} arg0\n   */\n  set ciphertext(arg0) {\n    const ptr0 = passArray8ToWasm0(arg0, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    wasm.__wbg_set_eip712domainmsg_name(this.__wbg_ptr, ptr0, len0);\n  }\n  /**\n   * The type of plaintext encrypted. The type should match FheType from tfhe-rs:\n   * <https://github.com/zama-ai/tfhe-rs/blob/main/tfhe/src/high_level_api/mod.rs>\n   * @returns {number}\n   */\n  get fhe_type() {\n    const ret = wasm.__wbg_get_typedciphertext_fhe_type(this.__wbg_ptr);\n    return ret;\n  }\n  /**\n   * The type of plaintext encrypted. The type should match FheType from tfhe-rs:\n   * <https://github.com/zama-ai/tfhe-rs/blob/main/tfhe/src/high_level_api/mod.rs>\n   * @param {number} arg0\n   */\n  set fhe_type(arg0) {\n    wasm.__wbg_set_typedciphertext_fhe_type(this.__wbg_ptr, arg0);\n  }\n  /**\n   * The external handle of the ciphertext (the handle used in the copro).\n   * @returns {Uint8Array}\n   */\n  get external_handle() {\n    const ret = wasm.__wbg_get_typedciphertext_external_handle(this.__wbg_ptr);\n    var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * The external handle of the ciphertext (the handle used in the copro).\n   * @param {Uint8Array} arg0\n   */\n  set external_handle(arg0) {\n    const ptr0 = passArray8ToWasm0(arg0, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    wasm.__wbg_set_eip712domainmsg_version(this.__wbg_ptr, ptr0, len0);\n  }\n  /**\n   * The ciphertext format, see CiphertextFormat documentation for details.\n   * CiphertextFormat::default() is used if unspecified.\n   * @returns {number}\n   */\n  get ciphertext_format() {\n    const ret = wasm.__wbg_get_typedciphertext_ciphertext_format(this.__wbg_ptr);\n    return ret;\n  }\n  /**\n   * The ciphertext format, see CiphertextFormat documentation for details.\n   * CiphertextFormat::default() is used if unspecified.\n   * @param {number} arg0\n   */\n  set ciphertext_format(arg0) {\n    wasm.__wbg_set_typedciphertext_ciphertext_format(this.__wbg_ptr, arg0);\n  }\n}\nconst TypedPlaintextFinalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm.__wbg_typedplaintext_free(ptr >>> 0, 1));\nclass TypedPlaintext {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(TypedPlaintext.prototype);\n    obj.__wbg_ptr = ptr;\n    TypedPlaintextFinalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    TypedPlaintextFinalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm.__wbg_typedplaintext_free(ptr, 0);\n  }\n  /**\n   * The actual plaintext in bytes.\n   * @returns {Uint8Array}\n   */\n  get bytes() {\n    const ret = wasm.__wbg_get_typedplaintext_bytes(this.__wbg_ptr);\n    var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * The actual plaintext in bytes.\n   * @param {Uint8Array} arg0\n   */\n  set bytes(arg0) {\n    const ptr0 = passArray8ToWasm0(arg0, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    wasm.__wbg_set_eip712domainmsg_name(this.__wbg_ptr, ptr0, len0);\n  }\n  /**\n   * The type of plaintext encrypted. The type should match FheType from tfhe-rs:\n   * <https://github.com/zama-ai/tfhe-rs/blob/main/tfhe/src/high_level_api/mod.rs>\n   * @returns {number}\n   */\n  get fhe_type() {\n    const ret = wasm.__wbg_get_typedplaintext_fhe_type(this.__wbg_ptr);\n    return ret;\n  }\n  /**\n   * The type of plaintext encrypted. The type should match FheType from tfhe-rs:\n   * <https://github.com/zama-ai/tfhe-rs/blob/main/tfhe/src/high_level_api/mod.rs>\n   * @param {number} arg0\n   */\n  set fhe_type(arg0) {\n    wasm.__wbg_set_typedplaintext_fhe_type(this.__wbg_ptr, arg0);\n  }\n}\nconst TypedSigncryptedCiphertextFinalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm.__wbg_typedsigncryptedciphertext_free(ptr >>> 0, 1));\nclass TypedSigncryptedCiphertext {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(TypedSigncryptedCiphertext.prototype);\n    obj.__wbg_ptr = ptr;\n    TypedSigncryptedCiphertextFinalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  static __unwrap(jsValue) {\n    if (!(jsValue instanceof TypedSigncryptedCiphertext)) {\n      return 0;\n    }\n    return jsValue.__destroy_into_raw();\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    TypedSigncryptedCiphertextFinalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm.__wbg_typedsigncryptedciphertext_free(ptr, 0);\n  }\n  /**\n   * The type of plaintext encrypted. The type should match FheType from tfhe-rs:\n   * <https://github.com/zama-ai/tfhe-rs/blob/main/tfhe/src/high_level_api/mod.rs>\n   * @returns {number}\n   */\n  get fhe_type() {\n    const ret = wasm.__wbg_get_typedciphertext_fhe_type(this.__wbg_ptr);\n    return ret;\n  }\n  /**\n   * The type of plaintext encrypted. The type should match FheType from tfhe-rs:\n   * <https://github.com/zama-ai/tfhe-rs/blob/main/tfhe/src/high_level_api/mod.rs>\n   * @param {number} arg0\n   */\n  set fhe_type(arg0) {\n    wasm.__wbg_set_typedciphertext_fhe_type(this.__wbg_ptr, arg0);\n  }\n  /**\n   * The signcrypted payload, using a hybrid encryption approach in\n   * sign-then-encrypt.\n   * @returns {Uint8Array}\n   */\n  get signcrypted_ciphertext() {\n    const ret = wasm.__wbg_get_typedsigncryptedciphertext_signcrypted_ciphertext(this.__wbg_ptr);\n    var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * The signcrypted payload, using a hybrid encryption approach in\n   * sign-then-encrypt.\n   * @param {Uint8Array} arg0\n   */\n  set signcrypted_ciphertext(arg0) {\n    const ptr0 = passArray8ToWasm0(arg0, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    wasm.__wbg_set_eip712domainmsg_name(this.__wbg_ptr, ptr0, len0);\n  }\n  /**\n   * The external handles that were originally in the request.\n   * @returns {Uint8Array}\n   */\n  get external_handle() {\n    const ret = wasm.__wbg_get_typedsigncryptedciphertext_external_handle(this.__wbg_ptr);\n    var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * The external handles that were originally in the request.\n   * @param {Uint8Array} arg0\n   */\n  set external_handle(arg0) {\n    const ptr0 = passArray8ToWasm0(arg0, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    wasm.__wbg_set_eip712domainmsg_version(this.__wbg_ptr, ptr0, len0);\n  }\n  /**\n   * The packing factor determines whether the decrypted plaintext\n   * has a different way of packing compared to what is specified in the plaintext modulus.\n   * @returns {number}\n   */\n  get packing_factor() {\n    const ret = wasm.__wbg_get_typedciphertext_ciphertext_format(this.__wbg_ptr);\n    return ret >>> 0;\n  }\n  /**\n   * The packing factor determines whether the decrypted plaintext\n   * has a different way of packing compared to what is specified in the plaintext modulus.\n   * @param {number} arg0\n   */\n  set packing_factor(arg0) {\n    wasm.__wbg_set_typedciphertext_ciphertext_format(this.__wbg_ptr, arg0);\n  }\n}\ntypeof FinalizationRegistry === 'undefined' ? {} : new FinalizationRegistry(ptr => wasm.__wbg_userdecryptionrequest_free(ptr >>> 0, 1));\nconst UserDecryptionResponseFinalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm.__wbg_userdecryptionresponse_free(ptr >>> 0, 1));\nclass UserDecryptionResponse {\n  static __unwrap(jsValue) {\n    if (!(jsValue instanceof UserDecryptionResponse)) {\n      return 0;\n    }\n    return jsValue.__destroy_into_raw();\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    UserDecryptionResponseFinalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm.__wbg_userdecryptionresponse_free(ptr, 0);\n  }\n  /**\n   * @returns {Uint8Array}\n   */\n  get signature() {\n    const ret = wasm.__wbg_get_userdecryptionresponse_signature(this.__wbg_ptr);\n    var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * @param {Uint8Array} arg0\n   */\n  set signature(arg0) {\n    const ptr0 = passArray8ToWasm0(arg0, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    wasm.__wbg_set_eip712domainmsg_name(this.__wbg_ptr, ptr0, len0);\n  }\n  /**\n   * This is the external signature created from the Eip712 domain\n   * on the structure, where userDecryptedShare is bc2wrap::serialize(&payload)\n   * struct UserDecryptResponseVerification {\n   *      bytes publicKey;\n   *      uint256\\[\\] ctHandles;\n   *      bytes userDecryptedShare; // serialization of payload\n   *      bytes extraData;\n   * }\n   * @returns {Uint8Array}\n   */\n  get external_signature() {\n    const ret = wasm.__wbg_get_userdecryptionresponse_external_signature(this.__wbg_ptr);\n    var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * This is the external signature created from the Eip712 domain\n   * on the structure, where userDecryptedShare is bc2wrap::serialize(&payload)\n   * struct UserDecryptResponseVerification {\n   *      bytes publicKey;\n   *      uint256\\[\\] ctHandles;\n   *      bytes userDecryptedShare; // serialization of payload\n   *      bytes extraData;\n   * }\n   * @param {Uint8Array} arg0\n   */\n  set external_signature(arg0) {\n    const ptr0 = passArray8ToWasm0(arg0, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    wasm.__wbg_set_eip712domainmsg_version(this.__wbg_ptr, ptr0, len0);\n  }\n  /**\n   * The actual \\[UserDecryptionResponsePayload\\].\n   * @returns {UserDecryptionResponsePayload | undefined}\n   */\n  get payload() {\n    const ret = wasm.__wbg_get_userdecryptionresponse_payload(this.__wbg_ptr);\n    return ret === 0 ? undefined : UserDecryptionResponsePayload.__wrap(ret);\n  }\n  /**\n   * The actual \\[UserDecryptionResponsePayload\\].\n   * @param {UserDecryptionResponsePayload | null} [arg0]\n   */\n  set payload(arg0) {\n    let ptr0 = 0;\n    if (!isLikeNone(arg0)) {\n      _assertClass(arg0, UserDecryptionResponsePayload);\n      ptr0 = arg0.__destroy_into_raw();\n    }\n    wasm.__wbg_set_userdecryptionresponse_payload(this.__wbg_ptr, ptr0);\n  }\n  /**\n   * Extra data used in the EIP712 signature - external_signature.\n   * @returns {Uint8Array}\n   */\n  get extra_data() {\n    const ret = wasm.__wbg_get_userdecryptionresponse_extra_data(this.__wbg_ptr);\n    var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * Extra data used in the EIP712 signature - external_signature.\n   * @param {Uint8Array} arg0\n   */\n  set extra_data(arg0) {\n    const ptr0 = passArray8ToWasm0(arg0, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    wasm.__wbg_set_eip712domainmsg_chain_id(this.__wbg_ptr, ptr0, len0);\n  }\n}\nconst UserDecryptionResponsePayloadFinalization = typeof FinalizationRegistry === 'undefined' ? {\n  register: () => {},\n  unregister: () => {}\n} : new FinalizationRegistry(ptr => wasm.__wbg_userdecryptionresponsepayload_free(ptr >>> 0, 1));\nclass UserDecryptionResponsePayload {\n  static __wrap(ptr) {\n    ptr = ptr >>> 0;\n    const obj = Object.create(UserDecryptionResponsePayload.prototype);\n    obj.__wbg_ptr = ptr;\n    UserDecryptionResponsePayloadFinalization.register(obj, obj.__wbg_ptr, obj);\n    return obj;\n  }\n  __destroy_into_raw() {\n    const ptr = this.__wbg_ptr;\n    this.__wbg_ptr = 0;\n    UserDecryptionResponsePayloadFinalization.unregister(this);\n    return ptr;\n  }\n  free() {\n    const ptr = this.__destroy_into_raw();\n    wasm.__wbg_userdecryptionresponsepayload_free(ptr, 0);\n  }\n  /**\n   * The server's signature verification key, Encoded using SEC1.\n   * Needed to validate the response, but MUST also be linked to a list of\n   * trusted keys.\n   * @returns {Uint8Array}\n   */\n  get verification_key() {\n    const ret = wasm.__wbg_get_userdecryptionresponsepayload_verification_key(this.__wbg_ptr);\n    var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * The server's signature verification key, Encoded using SEC1.\n   * Needed to validate the response, but MUST also be linked to a list of\n   * trusted keys.\n   * @param {Uint8Array} arg0\n   */\n  set verification_key(arg0) {\n    const ptr0 = passArray8ToWasm0(arg0, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    wasm.__wbg_set_eip712domainmsg_name(this.__wbg_ptr, ptr0, len0);\n  }\n  /**\n   * This is needed to ensure the response corresponds to the request.\n   * It is the digest of UserDecryptionLinker hashed using EIP712\n   * under the given domain in the request.\n   * @returns {Uint8Array}\n   */\n  get digest() {\n    const ret = wasm.__wbg_get_userdecryptionresponsepayload_digest(this.__wbg_ptr);\n    var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);\n    return v1;\n  }\n  /**\n   * This is needed to ensure the response corresponds to the request.\n   * It is the digest of UserDecryptionLinker hashed using EIP712\n   * under the given domain in the request.\n   * @param {Uint8Array} arg0\n   */\n  set digest(arg0) {\n    const ptr0 = passArray8ToWasm0(arg0, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    wasm.__wbg_set_eip712domainmsg_version(this.__wbg_ptr, ptr0, len0);\n  }\n  /**\n   * The resulting signcrypted ciphertexts, each ciphertext\n   * must be decrypted and then reconstructed with the other shares\n   * to produce the final plaintext.\n   * @returns {TypedSigncryptedCiphertext[]}\n   */\n  get signcrypted_ciphertexts() {\n    const ret = wasm.__wbg_get_userdecryptionresponsepayload_signcrypted_ciphertexts(this.__wbg_ptr);\n    var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();\n    wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);\n    return v1;\n  }\n  /**\n   * The resulting signcrypted ciphertexts, each ciphertext\n   * must be decrypted and then reconstructed with the other shares\n   * to produce the final plaintext.\n   * @param {TypedSigncryptedCiphertext[]} arg0\n   */\n  set signcrypted_ciphertexts(arg0) {\n    const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_malloc);\n    const len0 = WASM_VECTOR_LEN;\n    wasm.__wbg_set_userdecryptionresponsepayload_signcrypted_ciphertexts(this.__wbg_ptr, ptr0, len0);\n  }\n  /**\n   * The ID of the MPC party doing the user decryption. Used for polynomial\n   * reconstruction.\n   * @returns {number}\n   */\n  get party_id() {\n    const ret = wasm.__wbg_get_userdecryptionresponsepayload_party_id(this.__wbg_ptr);\n    return ret >>> 0;\n  }\n  /**\n   * The ID of the MPC party doing the user decryption. Used for polynomial\n   * reconstruction.\n   * @param {number} arg0\n   */\n  set party_id(arg0) {\n    wasm.__wbg_set_userdecryptionresponsepayload_party_id(this.__wbg_ptr, arg0);\n  }\n  /**\n   * The degree of the sharing scheme used.\n   * @returns {number}\n   */\n  get degree() {\n    const ret = wasm.__wbg_get_userdecryptionresponsepayload_degree(this.__wbg_ptr);\n    return ret >>> 0;\n  }\n  /**\n   * The degree of the sharing scheme used.\n   * @param {number} arg0\n   */\n  set degree(arg0) {\n    wasm.__wbg_set_userdecryptionresponsepayload_degree(this.__wbg_ptr, arg0);\n  }\n}\nfunction __wbg_load(_x9, _x0) {\n  return _wbg_load.apply(this, arguments);\n}\nfunction _wbg_load() {\n  _wbg_load = _asyncToGenerator(function* (module, imports) {\n    if (typeof Response === 'function' && module instanceof Response) {\n      if (typeof WebAssembly.instantiateStreaming === 'function') {\n        try {\n          return yield WebAssembly.instantiateStreaming(module, imports);\n        } catch (e) {\n          if (module.headers.get('Content-Type') != 'application/wasm') {\n            console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", e);\n          } else {\n            throw e;\n          }\n        }\n      }\n      const bytes = yield module.arrayBuffer();\n      return yield WebAssembly.instantiate(bytes, imports);\n    } else {\n      const instance = yield WebAssembly.instantiate(module, imports);\n      if (instance instanceof WebAssembly.Instance) {\n        return {\n          instance,\n          module\n        };\n      } else {\n        return instance;\n      }\n    }\n  });\n  return _wbg_load.apply(this, arguments);\n}\nfunction __wbg_get_imports() {\n  const imports = {};\n  imports.wbg = {};\n  imports.wbg.__wbg_String_8f0eb39a4a4c2f66 = function (arg0, arg1) {\n    const ret = String(arg1);\n    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len1 = WASM_VECTOR_LEN;\n    getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n    getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n  };\n  imports.wbg.__wbg_buffer_609cc3eee51ed158 = function (arg0) {\n    const ret = arg0.buffer;\n    return ret;\n  };\n  imports.wbg.__wbg_call_672a4d21634d4a24 = function () {\n    return handleError(function (arg0, arg1) {\n      const ret = arg0.call(arg1);\n      return ret;\n    }, arguments);\n  };\n  imports.wbg.__wbg_call_7cccdd69e0791ae2 = function () {\n    return handleError(function (arg0, arg1, arg2) {\n      const ret = arg0.call(arg1, arg2);\n      return ret;\n    }, arguments);\n  };\n  imports.wbg.__wbg_crypto_ed58b8e10a292839 = function (arg0) {\n    const ret = arg0.crypto;\n    return ret;\n  };\n  imports.wbg.__wbg_done_769e5ede4b31c67b = function (arg0) {\n    const ret = arg0.done;\n    return ret;\n  };\n  imports.wbg.__wbg_error_7534b8e9a36f1ab4 = function (arg0, arg1) {\n    let deferred0_0;\n    let deferred0_1;\n    try {\n      deferred0_0 = arg0;\n      deferred0_1 = arg1;\n      console.error(getStringFromWasm0(arg0, arg1));\n    } finally {\n      wasm.__wbindgen_free(deferred0_0, deferred0_1, 1);\n    }\n  };\n  imports.wbg.__wbg_getRandomValues_bcb4912f16000dc4 = function () {\n    return handleError(function (arg0, arg1) {\n      arg0.getRandomValues(arg1);\n    }, arguments);\n  };\n  imports.wbg.__wbg_get_67b2ba62fc30de12 = function () {\n    return handleError(function (arg0, arg1) {\n      const ret = Reflect.get(arg0, arg1);\n      return ret;\n    }, arguments);\n  };\n  imports.wbg.__wbg_get_b9b93047fe3cf45b = function (arg0, arg1) {\n    const ret = arg0[arg1 >>> 0];\n    return ret;\n  };\n  imports.wbg.__wbg_getwithrefkey_1dc361bd10053bfe = function (arg0, arg1) {\n    const ret = arg0[arg1];\n    return ret;\n  };\n  imports.wbg.__wbg_instanceof_ArrayBuffer_e14585432e3737fc = function (arg0) {\n    let result;\n    try {\n      result = arg0 instanceof ArrayBuffer;\n    } catch (_) {\n      result = false;\n    }\n    const ret = result;\n    return ret;\n  };\n  imports.wbg.__wbg_instanceof_Uint8Array_17156bcf118086a9 = function (arg0) {\n    let result;\n    try {\n      result = arg0 instanceof Uint8Array;\n    } catch (_) {\n      result = false;\n    }\n    const ret = result;\n    return ret;\n  };\n  imports.wbg.__wbg_isArray_a1eab7e0d067391b = function (arg0) {\n    const ret = Array.isArray(arg0);\n    return ret;\n  };\n  imports.wbg.__wbg_isSafeInteger_343e2beeeece1bb0 = function (arg0) {\n    const ret = Number.isSafeInteger(arg0);\n    return ret;\n  };\n  imports.wbg.__wbg_iterator_9a24c88df860dc65 = function () {\n    const ret = Symbol.iterator;\n    return ret;\n  };\n  imports.wbg.__wbg_length_a446193dc22c12f8 = function (arg0) {\n    const ret = arg0.length;\n    return ret;\n  };\n  imports.wbg.__wbg_length_e2d2a49132c1b256 = function (arg0) {\n    const ret = arg0.length;\n    return ret;\n  };\n  imports.wbg.__wbg_msCrypto_0a36e2ec3a343d26 = function (arg0) {\n    const ret = arg0.msCrypto;\n    return ret;\n  };\n  imports.wbg.__wbg_new_8a6f238a6ece86ea = function () {\n    const ret = new Error();\n    return ret;\n  };\n  imports.wbg.__wbg_new_a12002a7f91c75be = function (arg0) {\n    const ret = new Uint8Array(arg0);\n    return ret;\n  };\n  imports.wbg.__wbg_newnoargs_105ed471475aaf50 = function (arg0, arg1) {\n    const ret = new Function(getStringFromWasm0(arg0, arg1));\n    return ret;\n  };\n  imports.wbg.__wbg_newwithbyteoffsetandlength_d97e637ebe145a9a = function (arg0, arg1, arg2) {\n    const ret = new Uint8Array(arg0, arg1 >>> 0, arg2 >>> 0);\n    return ret;\n  };\n  imports.wbg.__wbg_newwithlength_a381634e90c276d4 = function (arg0) {\n    const ret = new Uint8Array(arg0 >>> 0);\n    return ret;\n  };\n  imports.wbg.__wbg_next_25feadfc0913fea9 = function (arg0) {\n    const ret = arg0.next;\n    return ret;\n  };\n  imports.wbg.__wbg_next_6574e1a8a62d1055 = function () {\n    return handleError(function (arg0) {\n      const ret = arg0.next();\n      return ret;\n    }, arguments);\n  };\n  imports.wbg.__wbg_node_02999533c4ea02e3 = function (arg0) {\n    const ret = arg0.node;\n    return ret;\n  };\n  imports.wbg.__wbg_process_5c1d670bc53614b8 = function (arg0) {\n    const ret = arg0.process;\n    return ret;\n  };\n  imports.wbg.__wbg_randomFillSync_ab2cfe79ebbf2740 = function () {\n    return handleError(function (arg0, arg1) {\n      arg0.randomFillSync(arg1);\n    }, arguments);\n  };\n  imports.wbg.__wbg_require_79b1e9274cde3c87 = function () {\n    return handleError(function () {\n      const ret = module.require;\n      return ret;\n    }, arguments);\n  };\n  imports.wbg.__wbg_serveridaddr_new = function (arg0) {\n    const ret = ServerIdAddr.__wrap(arg0);\n    return ret;\n  };\n  imports.wbg.__wbg_serveridaddr_unwrap = function (arg0) {\n    const ret = ServerIdAddr.__unwrap(arg0);\n    return ret;\n  };\n  imports.wbg.__wbg_set_65595bdd868b3009 = function (arg0, arg1, arg2) {\n    arg0.set(arg1, arg2 >>> 0);\n  };\n  imports.wbg.__wbg_stack_0ed75d68575b0f3c = function (arg0, arg1) {\n    const ret = arg1.stack;\n    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len1 = WASM_VECTOR_LEN;\n    getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n    getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n  };\n  imports.wbg.__wbg_static_accessor_GLOBAL_88a902d13a557d07 = function () {\n    const ret = typeof global$1 === 'undefined' ? null : global$1;\n    return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);\n  };\n  imports.wbg.__wbg_static_accessor_GLOBAL_THIS_56578be7e9f832b0 = function () {\n    const ret = typeof globalThis === 'undefined' ? null : globalThis;\n    return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);\n  };\n  imports.wbg.__wbg_static_accessor_SELF_37c5d418e4bf5819 = function () {\n    const ret = typeof self === 'undefined' ? null : self;\n    return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);\n  };\n  imports.wbg.__wbg_static_accessor_WINDOW_5de37043a91a9c40 = function () {\n    const ret = typeof window === 'undefined' ? null : window;\n    return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);\n  };\n  imports.wbg.__wbg_subarray_aa9065fa9dc5df96 = function (arg0, arg1, arg2) {\n    const ret = arg0.subarray(arg1 >>> 0, arg2 >>> 0);\n    return ret;\n  };\n  imports.wbg.__wbg_typedciphertext_new = function (arg0) {\n    const ret = TypedCiphertext.__wrap(arg0);\n    return ret;\n  };\n  imports.wbg.__wbg_typedciphertext_unwrap = function (arg0) {\n    const ret = TypedCiphertext.__unwrap(arg0);\n    return ret;\n  };\n  imports.wbg.__wbg_typedplaintext_new = function (arg0) {\n    const ret = TypedPlaintext.__wrap(arg0);\n    return ret;\n  };\n  imports.wbg.__wbg_typedsigncryptedciphertext_new = function (arg0) {\n    const ret = TypedSigncryptedCiphertext.__wrap(arg0);\n    return ret;\n  };\n  imports.wbg.__wbg_typedsigncryptedciphertext_unwrap = function (arg0) {\n    const ret = TypedSigncryptedCiphertext.__unwrap(arg0);\n    return ret;\n  };\n  imports.wbg.__wbg_userdecryptionresponse_unwrap = function (arg0) {\n    const ret = UserDecryptionResponse.__unwrap(arg0);\n    return ret;\n  };\n  imports.wbg.__wbg_value_cd1ffa7b1ab794f1 = function (arg0) {\n    const ret = arg0.value;\n    return ret;\n  };\n  imports.wbg.__wbg_versions_c71aa1626a93e0a1 = function (arg0) {\n    const ret = arg0.versions;\n    return ret;\n  };\n  imports.wbg.__wbindgen_as_number = function (arg0) {\n    const ret = +arg0;\n    return ret;\n  };\n  imports.wbg.__wbindgen_boolean_get = function (arg0) {\n    const v = arg0;\n    const ret = typeof v === 'boolean' ? v ? 1 : 0 : 2;\n    return ret;\n  };\n  imports.wbg.__wbindgen_debug_string = function (arg0, arg1) {\n    const ret = debugString(arg1);\n    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    const len1 = WASM_VECTOR_LEN;\n    getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n    getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n  };\n  imports.wbg.__wbindgen_error_new = function (arg0, arg1) {\n    const ret = new Error(getStringFromWasm0(arg0, arg1));\n    return ret;\n  };\n  imports.wbg.__wbindgen_in = function (arg0, arg1) {\n    const ret = arg0 in arg1;\n    return ret;\n  };\n  imports.wbg.__wbindgen_init_externref_table = function () {\n    const table = wasm.__wbindgen_export_4;\n    const offset = table.grow(4);\n    table.set(0, undefined);\n    table.set(offset + 0, undefined);\n    table.set(offset + 1, null);\n    table.set(offset + 2, true);\n    table.set(offset + 3, false);\n  };\n  imports.wbg.__wbindgen_is_function = function (arg0) {\n    const ret = typeof arg0 === 'function';\n    return ret;\n  };\n  imports.wbg.__wbindgen_is_null = function (arg0) {\n    const ret = arg0 === null;\n    return ret;\n  };\n  imports.wbg.__wbindgen_is_object = function (arg0) {\n    const val = arg0;\n    const ret = typeof val === 'object' && val !== null;\n    return ret;\n  };\n  imports.wbg.__wbindgen_is_string = function (arg0) {\n    const ret = typeof arg0 === 'string';\n    return ret;\n  };\n  imports.wbg.__wbindgen_is_undefined = function (arg0) {\n    const ret = arg0 === undefined;\n    return ret;\n  };\n  imports.wbg.__wbindgen_jsval_loose_eq = function (arg0, arg1) {\n    const ret = arg0 == arg1;\n    return ret;\n  };\n  imports.wbg.__wbindgen_memory = function () {\n    const ret = wasm.memory;\n    return ret;\n  };\n  imports.wbg.__wbindgen_number_get = function (arg0, arg1) {\n    const obj = arg1;\n    const ret = typeof obj === 'number' ? obj : undefined;\n    getDataViewMemory0().setFloat64(arg0 + 8 * 1, isLikeNone(ret) ? 0 : ret, true);\n    getDataViewMemory0().setInt32(arg0 + 4 * 0, !isLikeNone(ret), true);\n  };\n  imports.wbg.__wbindgen_string_get = function (arg0, arg1) {\n    const obj = arg1;\n    const ret = typeof obj === 'string' ? obj : undefined;\n    var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n    var len1 = WASM_VECTOR_LEN;\n    getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n    getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n  };\n  imports.wbg.__wbindgen_string_new = function (arg0, arg1) {\n    const ret = getStringFromWasm0(arg0, arg1);\n    return ret;\n  };\n  imports.wbg.__wbindgen_throw = function (arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n  };\n  return imports;\n}\nfunction __wbg_finalize_init(instance, module) {\n  wasm = instance.exports;\n  __wbg_init.__wbindgen_wasm_module = module;\n  cachedDataViewMemory0 = null;\n  cachedUint8ArrayMemory0 = null;\n  wasm.__wbindgen_start();\n  return wasm;\n}\nfunction __wbg_init(_x1) {\n  return _wbg_init.apply(this, arguments);\n}\nfunction _wbg_init() {\n  _wbg_init = _asyncToGenerator(function* (module_or_path) {\n    if (wasm !== undefined) return wasm;\n    if (typeof module_or_path !== 'undefined') {\n      if (Object.getPrototypeOf(module_or_path) === Object.prototype) {\n        ({\n          module_or_path\n        } = module_or_path);\n      } else {\n        console.warn('using deprecated parameters for the initialization function; pass a single object instead');\n      }\n    }\n    if (typeof module_or_path === 'undefined') {\n      module_or_path = new URL('kms_lib_bg.wasm', import.meta.url);\n    }\n    const imports = __wbg_get_imports();\n    if (typeof module_or_path === 'string' || typeof Request === 'function' && module_or_path instanceof Request || typeof URL === 'function' && module_or_path instanceof URL) {\n      module_or_path = fetch(module_or_path);\n    }\n    const {\n      instance,\n      module\n    } = yield __wbg_load(yield module_or_path, imports);\n    return __wbg_finalize_init(instance, module);\n  });\n  return _wbg_init.apply(this, arguments);\n}\nconst SERIALIZED_SIZE_LIMIT_CIPHERTEXT = BigInt(1024 * 1024 * 512);\nconst SERIALIZED_SIZE_LIMIT_PK = BigInt(1024 * 1024 * 512);\nconst SERIALIZED_SIZE_LIMIT_CRS = BigInt(1024 * 1024 * 512);\nconst cleanURL = url => {\n  if (!url) return '';\n  return url.endsWith('/') ? url.slice(0, -1) : url;\n};\nconst numberToHex = num => {\n  let hex = num.toString(16);\n  return hex.length % 2 ? '0' + hex : hex;\n};\nconst fromHexString = hexString => {\n  const arr = hexString.replace(/^(0x)/, '').match(/.{1,2}/g);\n  if (!arr) return new Uint8Array();\n  return Uint8Array.from(arr.map(byte => parseInt(byte, 16)));\n};\nfunction toHexString(bytes, with0x = false) {\n  return `${with0x ? '0x' : ''}${bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '')}`;\n}\nconst bytesToBigInt = function (byteArray) {\n  if (!byteArray || byteArray?.length === 0) {\n    return BigInt(0);\n  }\n  const hex = Array.from(byteArray).map(b => b.toString(16).padStart(2, '0')) // byte to hex\n  .join('');\n  return BigInt(`0x${hex}`);\n};\nfunction setAuth(init, auth) {\n  if (auth) {\n    switch (auth.__type) {\n      case 'BearerToken':\n        init.headers['Authorization'] = `Bearer ${auth.token}`;\n        break;\n      case 'ApiKeyHeader':\n        init.headers[auth.header || 'x-api-key'] = auth.value;\n        break;\n      case 'ApiKeyCookie':\n        if (typeof window !== 'undefined') {\n          document.cookie = `${auth.cookie || 'x-api-key'}=${auth.value}; path=/; SameSite=Lax; Secure; HttpOnly;`;\n          init.credentials = 'include';\n        } else {\n          let cookie = `${auth.cookie || 'x-api-key'}=${auth.value};`;\n          init.headers['Cookie'] = cookie;\n        }\n        break;\n    }\n  }\n  return init;\n}\nfunction getErrorCause(e) {\n  if (e instanceof Error && typeof e.cause === 'object' && e.cause !== null) {\n    return e.cause;\n  }\n  return undefined;\n}\nfunction getErrorCauseCode(e) {\n  const cause = getErrorCause(e);\n  if (!cause || !('code' in cause) || !cause.code) {\n    return undefined;\n  }\n  if (typeof cause.code !== 'string') {\n    return undefined;\n  }\n  return cause.code;\n}\nfunction getErrorCauseStatus(e) {\n  const cause = getErrorCause(e);\n  if (!cause || !('status' in cause) || cause.status === undefined) {\n    return undefined;\n  }\n  if (typeof cause.status !== 'number') {\n    return undefined;\n  }\n  return cause.status;\n}\nfunction throwRelayerResponseError(_x10, _x11) {\n  return _throwRelayerResponseError.apply(this, arguments);\n}\nfunction _throwRelayerResponseError() {\n  _throwRelayerResponseError = _asyncToGenerator(function* (operation, response) {\n    let message;\n    // Special case for 429\n    if (response.status === 429) {\n      message = `Relayer rate limit exceeded: Please wait and try again later.`;\n    } else {\n      switch (operation) {\n        case 'PUBLIC_DECRYPT':\n          {\n            message = `Public decrypt failed: relayer respond with HTTP code ${response.status}`;\n            break;\n          }\n        case 'USER_DECRYPT':\n          {\n            message = `User decrypt failed: relayer respond with HTTP code ${response.status}`;\n            break;\n          }\n        case 'KEY_URL':\n          {\n            message = `HTTP error! status: ${response.status}`;\n            break;\n          }\n        default:\n          {\n            const responseText = yield response.text();\n            message = `Relayer didn't response correctly. Bad status ${response.statusText}. Content: ${responseText}`;\n            break;\n          }\n      }\n    }\n    const cause = {\n      code: 'RELAYER_FETCH_ERROR',\n      operation,\n      status: response.status,\n      statusText: response.statusText,\n      url: response.url\n    };\n    throw new Error(message, {\n      cause\n    });\n  });\n  return _throwRelayerResponseError.apply(this, arguments);\n}\nfunction throwRelayerJSONError(operation, error) {\n  let message;\n  switch (operation) {\n    case 'PUBLIC_DECRYPT':\n      {\n        message = \"Public decrypt failed: Relayer didn't return a JSON\";\n        break;\n      }\n    case 'USER_DECRYPT':\n      {\n        message = \"User decrypt failed: Relayer didn't return a JSON\";\n        break;\n      }\n    default:\n      {\n        message = \"Relayer didn't return a JSON\";\n        break;\n      }\n  }\n  const cause = {\n    code: 'RELAYER_NO_JSON_ERROR',\n    operation,\n    error\n  };\n  throw new Error(message, {\n    cause\n  });\n}\nfunction throwRelayerUnexpectedJSONError(operation, error) {\n  let message;\n  switch (operation) {\n    case 'PUBLIC_DECRYPT':\n      {\n        message = 'Public decrypt failed: Relayer returned an unexpected JSON response';\n        break;\n      }\n    case 'USER_DECRYPT':\n      {\n        message = 'User decrypt failed: Relayer returned an unexpected JSON response';\n        break;\n      }\n    default:\n      {\n        message = 'Relayer returned an unexpected JSON response';\n        break;\n      }\n  }\n  const cause = {\n    code: 'RELAYER_UNEXPECTED_JSON_ERROR',\n    operation,\n    error\n  };\n  throw new Error(message, {\n    cause\n  });\n}\nfunction throwRelayerInternalError(operation, json) {\n  let message;\n  switch (operation) {\n    case 'PUBLIC_DECRYPT':\n      {\n        message = \"Pulbic decrypt failed: the public decryption didn't succeed for an unknown reason\";\n        break;\n      }\n    case 'USER_DECRYPT':\n      {\n        message = \"User decrypt failed: the user decryption didn't succeed for an unknown reason\";\n        break;\n      }\n    default:\n      {\n        message = \"Relayer didn't response correctly.\";\n        break;\n      }\n  }\n  const cause = {\n    code: 'RELAYER_INTERNAL_ERROR',\n    operation,\n    error: json\n  };\n  throw new Error(message, {\n    cause\n  });\n}\nfunction throwRelayerUnknownError(operation, error, message) {\n  if (!message) {\n    switch (operation) {\n      case 'PUBLIC_DECRYPT':\n        {\n          message = \"Public decrypt failed: Relayer didn't respond\";\n          break;\n        }\n      case 'USER_DECRYPT':\n        {\n          message = \"User decrypt failed: Relayer didn't respond\";\n          break;\n        }\n      default:\n        {\n          message = \"Relayer didn't response correctly. Bad JSON.\";\n          break;\n        }\n    }\n  }\n  const cause = {\n    code: 'RELAYER_UNKNOWN_ERROR',\n    operation,\n    error\n  };\n  throw new Error(message ?? \"Relayer didn't response correctly.\", {\n    cause\n  });\n}\nfunction assertIsRelayerFetchResponseJson(json) {\n  if (!json || typeof json !== 'object') {\n    throw new Error('Unexpected response JSON.');\n  }\n  if (!('response' in json && json.response !== null && json.response !== undefined)) {\n    throw new Error(\"Unexpected response JSON format: missing 'response' property.\");\n  }\n}\nfunction fetchRelayerJsonRpcPost(_x12, _x13, _x14, _x15) {\n  return _fetchRelayerJsonRpcPost.apply(this, arguments);\n}\nfunction _fetchRelayerJsonRpcPost() {\n  _fetchRelayerJsonRpcPost = _asyncToGenerator(function* (relayerOperation, url, payload, options) {\n    const init = setAuth({\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(payload)\n    }, options?.auth);\n    let response;\n    let json;\n    try {\n      response = yield fetch(url, init);\n    } catch (e) {\n      throwRelayerUnknownError(relayerOperation, e);\n    }\n    if (!response.ok) {\n      yield throwRelayerResponseError(relayerOperation, response);\n    }\n    let parsed;\n    try {\n      parsed = yield response.json();\n    } catch (e) {\n      throwRelayerJSONError(relayerOperation, e);\n    }\n    try {\n      assertIsRelayerFetchResponseJson(parsed);\n      json = parsed;\n    } catch (e) {\n      throwRelayerUnexpectedJSONError(relayerOperation, e);\n    }\n    return json;\n  });\n  return _fetchRelayerJsonRpcPost.apply(this, arguments);\n}\nfunction fetchRelayerGet(_x16, _x17) {\n  return _fetchRelayerGet.apply(this, arguments);\n} // export type RelayerKeysItem = {\n//   data_id: string;\n//   param_choice: number;\n//   urls: string[];\n//   signatures: string[];\n// };\n// export type RelayerKey = {\n//   data_id: string;\n//   param_choice: number;\n//   signatures: string[];\n//   urls: string[];\n// };\n// export type RelayerKeys = {\n//   response: {\n//     fhe_key_info: {\n//       fhe_public_key: RelayerKey;\n//       fhe_server_key: RelayerKey;\n//     }[];\n//     verf_public_key: {\n//       key_id: string;\n//       server_id: number;\n//       verf_public_key_address: string;\n//       verf_public_key_url: string;\n//     }[];\n//     crs: {\n//       [key: string]: RelayerKeysItem;\n//     };\n//   };\n//   status: string;\n// };\nfunction _fetchRelayerGet() {\n  _fetchRelayerGet = _asyncToGenerator(function* (relayerOperation, url) {\n    let response;\n    let json;\n    try {\n      response = yield fetch(url);\n    } catch (e) {\n      throwRelayerUnknownError(relayerOperation, e);\n    }\n    if (!response.ok) {\n      yield throwRelayerResponseError(relayerOperation, response);\n    }\n    let parsed;\n    try {\n      parsed = yield response.json();\n    } catch (e) {\n      throwRelayerJSONError(relayerOperation, e);\n    }\n    try {\n      assertIsRelayerFetchResponseJson(parsed);\n      json = parsed;\n    } catch (e) {\n      throwRelayerUnexpectedJSONError(relayerOperation, e);\n    }\n    return json;\n  });\n  return _fetchRelayerGet.apply(this, arguments);\n}\nconst keyurlCache = {};\nconst getKeysFromRelayer = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* (url, publicKeyId) {\n    if (keyurlCache[url]) {\n      return keyurlCache[url];\n    }\n    const data = yield fetchRelayerGet('KEY_URL', `${url}/v1/keyurl`);\n    try {\n      // const response = await fetch(`${url}/v1/keyurl`);\n      // if (!response.ok) {\n      //   await throwRelayerResponseError(\"KEY_URL\", response);\n      // }\n      //const data: RelayerKeys = await response.json();\n      //if (data) {\n      let pubKeyUrl;\n      // If no publicKeyId is provided, use the first one\n      // Warning: if there are multiple keys available, the first one will most likely never be the\n      // same between several calls (fetching the infos is non-deterministic)\n      if (!publicKeyId) {\n        pubKeyUrl = data.response.fhe_key_info[0].fhe_public_key.urls[0];\n        publicKeyId = data.response.fhe_key_info[0].fhe_public_key.data_id;\n      } else {\n        // If a publicKeyId is provided, get the corresponding info\n        const keyInfo = data.response.fhe_key_info.find(info => info.fhe_public_key.data_id === publicKeyId);\n        if (!keyInfo) {\n          throw new Error(`Could not find FHE key info with data_id ${publicKeyId}`);\n        }\n        // TODO: Get a given party's public key url instead of the first one\n        pubKeyUrl = keyInfo.fhe_public_key.urls[0];\n      }\n      const publicKeyResponse = yield fetch(pubKeyUrl);\n      if (!publicKeyResponse.ok) {\n        throw new Error(`HTTP error! status: ${publicKeyResponse.status} on ${publicKeyResponse.url}`);\n      }\n      let publicKey;\n      if (typeof publicKeyResponse.bytes === 'function') {\n        // bytes is not widely supported yet\n        publicKey = yield publicKeyResponse.bytes();\n      } else {\n        publicKey = new Uint8Array(yield publicKeyResponse.arrayBuffer());\n      }\n      const publicParamsUrl = data.response.crs['2048'].urls[0];\n      const publicParamsId = data.response.crs['2048'].data_id;\n      const publicParams2048Response = yield fetch(publicParamsUrl);\n      if (!publicParams2048Response.ok) {\n        throw new Error(`HTTP error! status: ${publicParams2048Response.status} on ${publicParams2048Response.url}`);\n      }\n      let publicParams2048;\n      if (typeof publicParams2048Response.bytes === 'function') {\n        // bytes is not widely supported yet\n        publicParams2048 = yield publicParams2048Response.bytes();\n      } else {\n        publicParams2048 = new Uint8Array(yield publicParams2048Response.arrayBuffer());\n      }\n      let pub_key;\n      try {\n        pub_key = TFHE.TfheCompactPublicKey.safe_deserialize(publicKey, SERIALIZED_SIZE_LIMIT_PK);\n      } catch (e) {\n        throw new Error('Invalid public key (deserialization failed)', {\n          cause: e\n        });\n      }\n      let crs;\n      try {\n        crs = TFHE.CompactPkeCrs.safe_deserialize(new Uint8Array(publicParams2048), SERIALIZED_SIZE_LIMIT_CRS);\n      } catch (e) {\n        throw new Error('Invalid crs (deserialization failed)', {\n          cause: e\n        });\n      }\n      const result = {\n        publicKey: pub_key,\n        publicKeyId,\n        publicParams: {\n          2048: {\n            publicParams: crs,\n            publicParamsId\n          }\n        }\n      };\n      keyurlCache[url] = result;\n      return result;\n      // } else {\n      //   throw new Error('No public key available');\n      // }\n    } catch (e) {\n      throw new Error('Impossible to fetch public key: wrong relayer url.', {\n        cause: e\n      });\n    }\n  });\n  return function getKeysFromRelayer(_x18, _x19) {\n    return _ref2.apply(this, arguments);\n  };\n}();\nconst abiKmsVerifier = ['function getKmsSigners() view returns (address[])', 'function getThreshold() view returns (uint256)'];\nconst abiInputVerifier = ['function getCoprocessorSigners() view returns (address[])', 'function getThreshold() view returns (uint256)'];\nconst getProvider = config => {\n  if (typeof config.network === 'string') {\n    return new JsonRpcProvider(config.network);\n  } else if (config.network) {\n    return new BrowserProvider(config.network);\n  }\n  throw new Error('You must provide a network URL or a EIP1193 object (eg: window.ethereum)');\n};\nconst getChainId = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator(function* (provider, config) {\n    if (config.chainId && typeof config.chainId === 'number') {\n      return config.chainId;\n    } else if (config.chainId && typeof config.chainId !== 'number') {\n      throw new Error('chainId must be a number.');\n    } else {\n      const chainId = (yield provider.getNetwork()).chainId;\n      return Number(chainId);\n    }\n  });\n  return function getChainId(_x20, _x21) {\n    return _ref3.apply(this, arguments);\n  };\n}();\nconst getTfheCompactPublicKey = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator(function* (config) {\n    if (config.relayerUrl && !config.publicKey) {\n      const inputs = yield getKeysFromRelayer(cleanURL(config.relayerUrl));\n      return {\n        publicKey: inputs.publicKey,\n        publicKeyId: inputs.publicKeyId\n      };\n    } else if (config.publicKey && config.publicKey.data && config.publicKey.id) {\n      const buff = config.publicKey.data;\n      try {\n        return {\n          publicKey: TFHE.TfheCompactPublicKey.safe_deserialize(buff, SERIALIZED_SIZE_LIMIT_PK),\n          publicKeyId: config.publicKey.id\n        };\n      } catch (e) {\n        throw new Error('Invalid public key (deserialization failed)', {\n          cause: e\n        });\n      }\n    } else {\n      throw new Error('You must provide a public key with its public key ID.');\n    }\n  });\n  return function getTfheCompactPublicKey(_x22) {\n    return _ref4.apply(this, arguments);\n  };\n}();\nconst getPublicParams = /*#__PURE__*/function () {\n  var _ref5 = _asyncToGenerator(function* (config) {\n    if (config.relayerUrl && !config.publicParams) {\n      const inputs = yield getKeysFromRelayer(cleanURL(config.relayerUrl));\n      return inputs.publicParams;\n    } else if (config.publicParams && config.publicParams['2048']) {\n      const buff = config.publicParams['2048'].publicParams;\n      try {\n        return {\n          2048: {\n            publicParams: TFHE.CompactPkeCrs.safe_deserialize(buff, SERIALIZED_SIZE_LIMIT_CRS),\n            publicParamsId: config.publicParams['2048'].publicParamsId\n          }\n        };\n      } catch (e) {\n        throw new Error('Invalid public key (deserialization failed)', {\n          cause: e\n        });\n      }\n    } else {\n      throw new Error('You must provide a valid CRS with its CRS ID.');\n    }\n  });\n  return function getPublicParams(_x23) {\n    return _ref5.apply(this, arguments);\n  };\n}();\nconst getKMSSigners = /*#__PURE__*/function () {\n  var _ref6 = _asyncToGenerator(function* (provider, config) {\n    const kmsContract = new Contract(config.kmsContractAddress, abiKmsVerifier, provider);\n    const signers = yield kmsContract.getKmsSigners();\n    return signers;\n  });\n  return function getKMSSigners(_x24, _x25) {\n    return _ref6.apply(this, arguments);\n  };\n}();\nconst getKMSSignersThreshold = /*#__PURE__*/function () {\n  var _ref7 = _asyncToGenerator(function* (provider, config) {\n    const kmsContract = new Contract(config.kmsContractAddress, abiKmsVerifier, provider);\n    const threshold = yield kmsContract.getThreshold();\n    return Number(threshold); // threshold is always supposed to fit in a number\n  });\n  return function getKMSSignersThreshold(_x26, _x27) {\n    return _ref7.apply(this, arguments);\n  };\n}();\nconst getCoprocessorSigners = /*#__PURE__*/function () {\n  var _ref8 = _asyncToGenerator(function* (provider, config) {\n    const inputContract = new Contract(config.inputVerifierContractAddress, abiInputVerifier, provider);\n    const signers = yield inputContract.getCoprocessorSigners();\n    return signers;\n  });\n  return function getCoprocessorSigners(_x28, _x29) {\n    return _ref8.apply(this, arguments);\n  };\n}();\nconst getCoprocessorSignersThreshold = /*#__PURE__*/function () {\n  var _ref9 = _asyncToGenerator(function* (provider, config) {\n    const inputContract = new Contract(config.inputVerifierContractAddress, abiInputVerifier, provider);\n    const threshold = yield inputContract.getThreshold();\n    return Number(threshold); // threshold is always supposed to fit in a number\n  });\n  return function getCoprocessorSignersThreshold(_x30, _x31) {\n    return _ref9.apply(this, arguments);\n  };\n}();\nconst NumEncryptedBits = {\n  0: 2,\n  // ebool\n  2: 8,\n  // euint8\n  3: 16,\n  // euint16\n  4: 32,\n  // euint32\n  5: 64,\n  // euint64\n  6: 128,\n  // euint128\n  7: 160,\n  // eaddress\n  8: 256 // euint256\n};\nfunction checkEncryptedBits(handles) {\n  let total = 0;\n  for (const handle of handles) {\n    if (handle.length !== 66) {\n      throw new Error(`Handle ${handle} is not of valid length`);\n    }\n    const hexPair = handle.slice(-4, -2).toLowerCase();\n    const typeDiscriminant = parseInt(hexPair, 16);\n    if (!(typeDiscriminant in NumEncryptedBits)) {\n      throw new Error(`Handle ${handle} is not of valid type`);\n    }\n    total += NumEncryptedBits[typeDiscriminant];\n    // enforce 2048bit limit\n    if (total > 2048) {\n      throw new Error('Cannot decrypt more than 2048 encrypted bits in a single request');\n    }\n  }\n  return total;\n}\n\n// Add type checking\nconst getAddress$1 = value => getAddress$2(value);\nconst aclABI$1 = ['function persistAllowed(bytes32 handle, address account) view returns (bool)'];\nconst MAX_USER_DECRYPT_CONTRACT_ADDRESSES = 10;\nconst MAX_USER_DECRYPT_DURATION_DAYS = BigInt(365);\nfunction formatAccordingToType(decryptedBigInt, type) {\n  if (type === 0) {\n    // ebool\n    return decryptedBigInt === BigInt(1);\n  } else if (type === 7) {\n    // eaddress\n    return getAddress$1('0x' + decryptedBigInt.toString(16).padStart(40, '0'));\n  } else if (type === 9) {\n    // ebytes64\n    return '0x' + decryptedBigInt.toString(16).padStart(128, '0');\n  } else if (type === 10) {\n    // ebytes128\n    return '0x' + decryptedBigInt.toString(16).padStart(256, '0');\n  } else if (type === 11) {\n    // ebytes256\n    return '0x' + decryptedBigInt.toString(16).padStart(512, '0');\n  } // euintXXX\n  return decryptedBigInt;\n}\nfunction buildUserDecryptedResult(handles, listBigIntDecryptions) {\n  let typesList = [];\n  for (const handle of handles) {\n    const hexPair = handle.slice(-4, -2).toLowerCase();\n    const typeDiscriminant = parseInt(hexPair, 16);\n    typesList.push(typeDiscriminant);\n  }\n  let results = {};\n  handles.forEach((handle, idx) => results[handle] = formatAccordingToType(listBigIntDecryptions[idx], typesList[idx]));\n  return results;\n}\nfunction checkDeadlineValidity(startTimestamp, durationDays) {\n  if (durationDays === BigInt(0)) {\n    throw Error('durationDays is null');\n  }\n  if (durationDays > MAX_USER_DECRYPT_DURATION_DAYS) {\n    throw Error(`durationDays is above max duration of ${MAX_USER_DECRYPT_DURATION_DAYS}`);\n  }\n  const currentTimestamp = BigInt(Math.floor(Date.now() / 1000));\n  if (startTimestamp > currentTimestamp) {\n    throw Error('startTimestamp is set in the future');\n  }\n  const durationInSeconds = durationDays * BigInt(86400);\n  if (startTimestamp + durationInSeconds < currentTimestamp) {\n    throw Error('User decrypt request has expired');\n  }\n}\nconst userDecryptRequest = (kmsSigners, gatewayChainId, chainId, verifyingContractAddress, aclContractAddress, relayerUrl, provider, instanceOptions) => (/*#__PURE__*/function () {\n  var _ref0 = _asyncToGenerator(function* (_handles, privateKey, publicKey, signature, contractAddresses, userAddress, startTimestamp, durationDays, options) {\n    const extraData = '0x00';\n    let pubKey;\n    let privKey;\n    try {\n      pubKey = TKMS.u8vec_to_ml_kem_pke_pk(fromHexString(publicKey));\n      privKey = TKMS.u8vec_to_ml_kem_pke_sk(fromHexString(privateKey));\n    } catch (e) {\n      throw new Error('Invalid public or private key', {\n        cause: e\n      });\n    }\n    // Casting handles if string\n    const signatureSanitized = signature.replace(/^(0x)/, '');\n    const publicKeySanitized = publicKey.replace(/^(0x)/, '');\n    const handles = _handles.map(h => ({\n      handle: typeof h.handle === 'string' ? toHexString(fromHexString(h.handle), true) : toHexString(h.handle, true),\n      contractAddress: getAddress$1(h.contractAddress)\n    }));\n    checkEncryptedBits(handles.map(h => h.handle));\n    checkDeadlineValidity(BigInt(startTimestamp), BigInt(durationDays));\n    const acl = new ethers.Contract(aclContractAddress, aclABI$1, provider);\n    const verifications = handles.map(/*#__PURE__*/function () {\n      var _ref1 = _asyncToGenerator(function* ({\n        handle,\n        contractAddress\n      }) {\n        const userAllowed = yield acl.persistAllowed(handle, userAddress);\n        const contractAllowed = yield acl.persistAllowed(handle, contractAddress);\n        if (!userAllowed) {\n          throw new Error(`User ${userAddress} is not authorized to user decrypt handle ${handle}!`);\n        }\n        if (!contractAllowed) {\n          throw new Error(`dapp contract ${contractAddress} is not authorized to user decrypt handle ${handle}!`);\n        }\n        if (userAddress === contractAddress) {\n          throw new Error(`userAddress ${userAddress} should not be equal to contractAddress when requesting user decryption!`);\n        }\n      });\n      return function (_x41) {\n        return _ref1.apply(this, arguments);\n      };\n    }());\n    const contractAddressesLength = contractAddresses.length;\n    if (contractAddressesLength === 0) {\n      throw Error('contractAddresses is empty');\n    }\n    if (contractAddressesLength > MAX_USER_DECRYPT_CONTRACT_ADDRESSES) {\n      throw Error(`contractAddresses max length of ${MAX_USER_DECRYPT_CONTRACT_ADDRESSES} exceeded`);\n    }\n    yield Promise.all(verifications).catch(e => {\n      throw e;\n    });\n    const payloadForRequest = {\n      handleContractPairs: handles,\n      requestValidity: {\n        startTimestamp: startTimestamp.toString(),\n        // Convert to string\n        durationDays: durationDays.toString() // Convert to string\n      },\n      contractsChainId: chainId.toString(),\n      // Convert to string\n      contractAddresses: contractAddresses.map(c => getAddress$1(c)),\n      userAddress: getAddress$1(userAddress),\n      signature: signatureSanitized,\n      publicKey: publicKeySanitized,\n      extraData\n    };\n    const json = yield fetchRelayerJsonRpcPost('USER_DECRYPT', `${relayerUrl}/v1/user-decrypt`, payloadForRequest, instanceOptions ?? options);\n    // assume the KMS Signers have the correct order\n    let indexedKmsSigners = kmsSigners.map((signer, index) => {\n      return TKMS.new_server_id_addr(index + 1, signer);\n    });\n    const client = TKMS.new_client(indexedKmsSigners, userAddress, 'default');\n    try {\n      const buffer = new ArrayBuffer(32);\n      const view = new DataView(buffer);\n      view.setUint32(28, gatewayChainId, false);\n      const chainIdArrayBE = new Uint8Array(buffer);\n      const eip712Domain = {\n        name: 'Decryption',\n        version: '1',\n        chain_id: chainIdArrayBE,\n        verifying_contract: verifyingContractAddress,\n        salt: null\n      };\n      const payloadForVerification = {\n        signature: signatureSanitized,\n        client_address: userAddress,\n        enc_key: publicKeySanitized,\n        ciphertext_handles: handles.map(h => h.handle.replace(/^0x/, '')),\n        eip712_verifying_contract: verifyingContractAddress\n      };\n      const decryption = TKMS.process_user_decryption_resp_from_js(client, payloadForVerification, eip712Domain, json.response, pubKey, privKey, true);\n      const listBigIntDecryptions = decryption.map(d => bytesToBigInt(d.bytes));\n      const results = buildUserDecryptedResult(handles.map(h => h.handle), listBigIntDecryptions);\n      return results;\n    } catch (e) {\n      throw new Error('An error occured during decryption', {\n        cause: e\n      });\n    }\n  });\n  return function (_x32, _x33, _x34, _x35, _x36, _x37, _x38, _x39, _x40) {\n    return _ref0.apply(this, arguments);\n  };\n}());\nconst checkEncryptedValue = (value, bits) => {\n  if (value == null) throw new Error('Missing value');\n  let limit;\n  if (bits >= 8) {\n    limit = BigInt(`0x${new Array(bits / 8).fill(null).reduce(v => `${v}ff`, '')}`);\n  } else {\n    limit = BigInt(2 ** bits - 1);\n  }\n  if (typeof value !== 'number' && typeof value !== 'bigint') throw new Error('Value must be a number or a bigint.');\n  if (value > limit) {\n    throw new Error(`The value exceeds the limit for ${bits}bits integer (${limit.toString()}).`);\n  }\n};\nconst createEncryptedInput = ({\n  aclContractAddress,\n  chainId,\n  tfheCompactPublicKey,\n  publicParams,\n  contractAddress,\n  userAddress\n}) => {\n  if (!isAddress(contractAddress)) {\n    throw new Error('Contract address is not a valid address.');\n  }\n  if (!isAddress(userAddress)) {\n    throw new Error('User address is not a valid address.');\n  }\n  const publicKey = tfheCompactPublicKey;\n  const bits = [];\n  const builder = TFHE.CompactCiphertextList.builder(publicKey);\n  let ciphertextWithZKProof = new Uint8Array(); // updated in `_prove`\n  const checkLimit = added => {\n    if (bits.reduce((acc, val) => acc + Math.max(2, val), 0) + added > 2048) {\n      throw Error('Packing more than 2048 bits in a single input ciphertext is unsupported');\n    }\n    if (bits.length + 1 > 256) throw Error('Packing more than 256 variables in a single input ciphertext is unsupported');\n  };\n  return {\n    addBool(value) {\n      if (value == null) throw new Error('Missing value');\n      if (typeof value !== 'boolean' && typeof value !== 'number' && typeof value !== 'bigint') throw new Error('The value must be a boolean, a number or a bigint.');\n      if (Number(value) > 1) throw new Error('The value must be 1 or 0.');\n      checkEncryptedValue(Number(value), 1);\n      checkLimit(2);\n      builder.push_boolean(!!value);\n      bits.push(1); // ebool takes 2 encrypted bits\n      return this;\n    },\n    add8(value) {\n      checkEncryptedValue(value, 8);\n      checkLimit(8);\n      builder.push_u8(Number(value));\n      bits.push(8);\n      return this;\n    },\n    add16(value) {\n      checkEncryptedValue(value, 16);\n      checkLimit(16);\n      builder.push_u16(Number(value));\n      bits.push(16);\n      return this;\n    },\n    add32(value) {\n      checkEncryptedValue(value, 32);\n      checkLimit(32);\n      builder.push_u32(Number(value));\n      bits.push(32);\n      return this;\n    },\n    add64(value) {\n      checkEncryptedValue(value, 64);\n      checkLimit(64);\n      builder.push_u64(BigInt(value));\n      bits.push(64);\n      return this;\n    },\n    add128(value) {\n      checkEncryptedValue(value, 128);\n      checkLimit(128);\n      builder.push_u128(BigInt(value));\n      bits.push(128);\n      return this;\n    },\n    addAddress(value) {\n      if (!isAddress(value)) {\n        throw new Error('The value must be a valid address.');\n      }\n      checkLimit(160);\n      builder.push_u160(BigInt(value));\n      bits.push(160);\n      return this;\n    },\n    add256(value) {\n      checkEncryptedValue(value, 256);\n      checkLimit(256);\n      builder.push_u256(BigInt(value));\n      bits.push(256);\n      return this;\n    },\n    addBytes64(value) {\n      if (value.length !== 64) throw Error('Uncorrect length of input Uint8Array, should be 64 for an ebytes64');\n      const bigIntValue = bytesToBigInt(value);\n      checkEncryptedValue(bigIntValue, 512);\n      checkLimit(512);\n      builder.push_u512(bigIntValue);\n      bits.push(512);\n      return this;\n    },\n    addBytes128(value) {\n      if (value.length !== 128) throw Error('Uncorrect length of input Uint8Array, should be 128 for an ebytes128');\n      const bigIntValue = bytesToBigInt(value);\n      checkEncryptedValue(bigIntValue, 1024);\n      checkLimit(1024);\n      builder.push_u1024(bigIntValue);\n      bits.push(1024);\n      return this;\n    },\n    addBytes256(value) {\n      if (value.length !== 256) throw Error('Uncorrect length of input Uint8Array, should be 256 for an ebytes256');\n      const bigIntValue = bytesToBigInt(value);\n      checkEncryptedValue(bigIntValue, 2048);\n      checkLimit(2048);\n      builder.push_u2048(bigIntValue);\n      bits.push(2048);\n      return this;\n    },\n    getBits() {\n      return bits;\n    },\n    encrypt() {\n      const getClosestPP = () => {\n        const getKeys = obj => Object.keys(obj);\n        const totalBits = bits.reduce((total, v) => total + v, 0);\n        const ppTypes = getKeys(publicParams);\n        const closestPP = ppTypes.find(k => Number(k) >= totalBits);\n        if (!closestPP) {\n          throw new Error(`Too many bits in provided values. Maximum is ${ppTypes[ppTypes.length - 1]}.`);\n        }\n        return closestPP;\n      };\n      const closestPP = getClosestPP();\n      const pp = publicParams[closestPP].publicParams;\n      const buffContract = fromHexString(contractAddress);\n      const buffUser = fromHexString(userAddress);\n      const buffAcl = fromHexString(aclContractAddress);\n      const buffChainId = fromHexString(chainId.toString(16).padStart(64, '0'));\n      const auxData = new Uint8Array(buffContract.length + buffUser.length + buffAcl.length + 32);\n      auxData.set(buffContract, 0);\n      auxData.set(buffUser, 20);\n      auxData.set(buffAcl, 40);\n      auxData.set(buffChainId, auxData.length - buffChainId.length);\n      const encrypted = builder.build_with_proof_packed(pp, auxData, TFHE.ZkComputeLoad.Verify);\n      ciphertextWithZKProof = encrypted.safe_serialize(SERIALIZED_SIZE_LIMIT_CIPHERTEXT);\n      return ciphertextWithZKProof;\n    }\n  };\n};\nconst ENCRYPTION_TYPES = {\n  1: 0,\n  // ebool takes 2 encrypted bits\n  8: 2,\n  16: 3,\n  32: 4,\n  64: 5,\n  128: 6,\n  160: 7,\n  256: 8,\n  512: 9,\n  1024: 10,\n  2048: 11\n};\nconst MAX_UINT64 = BigInt('18446744073709551615'); // 2^64 - 1\nconst computeHandles = (ciphertextWithZKProof, bitwidths, aclContractAddress, chainId, ciphertextVersion) => {\n  // Should be identical to:\n  // https://github.com/zama-ai/fhevm-backend/blob/bae00d1b0feafb63286e94acdc58dc88d9c481bf/fhevm-engine/zkproof-worker/src/verifier.rs#L301\n  const blob_hash = createHash('keccak256').update(Buffer.from(ciphertextWithZKProof)).digest();\n  const aclContractAddress20Bytes = Buffer.from(fromHexString(aclContractAddress));\n  const hex = chainId.toString(16).padStart(64, '0'); // 64 hex chars = 32 bytes\n  const chainId32Bytes = Buffer.from(hex, 'hex');\n  const handles = bitwidths.map((bitwidth, encryptionIndex) => {\n    const encryptionType = ENCRYPTION_TYPES[bitwidth];\n    const encryptionIndex1Byte = Buffer.from([encryptionIndex]);\n    const handleHash = createHash('keccak256').update(blob_hash).update(encryptionIndex1Byte).update(aclContractAddress20Bytes).update(chainId32Bytes).digest();\n    const dataInput = new Uint8Array(32);\n    dataInput.set(handleHash, 0);\n    // Check if chainId exceeds 8 bytes\n    if (BigInt(chainId) > MAX_UINT64) {\n      throw new Error('ChainId exceeds maximum allowed value (8 bytes)'); // fhevm assumes chainID is only taking up to 8 bytes\n    }\n    const chainId8Bytes = fromHexString(hex).slice(24, 32);\n    dataInput[21] = encryptionIndex;\n    dataInput.set(chainId8Bytes, 22);\n    dataInput[30] = encryptionType;\n    dataInput[31] = ciphertextVersion;\n    return dataInput;\n  });\n  return handles;\n};\n\n// Add type checking\nconst getAddress = value => getAddress$2(value);\nconst currentCiphertextVersion = () => {\n  return 0;\n};\nfunction isThresholdReached$1(coprocessorSigners, recoveredAddresses, threshold) {\n  const addressMap = new Map();\n  recoveredAddresses.forEach((address, index) => {\n    if (addressMap.has(address)) {\n      const duplicateValue = address;\n      throw new Error(`Duplicate coprocessor signer address found: ${duplicateValue} appears multiple times in recovered addresses`);\n    }\n    addressMap.set(address, index);\n  });\n  for (const address of recoveredAddresses) {\n    if (!coprocessorSigners.includes(address)) {\n      throw new Error(`Invalid address found: ${address} is not in the list of coprocessor signers`);\n    }\n  }\n  return recoveredAddresses.length >= threshold;\n}\nfunction isFhevmRelayerInputProofResponse(json) {\n  const response = json.response;\n  if (typeof response !== 'object' || response === null) {\n    return false;\n  }\n  if (!('handles' in response && Array.isArray(response.handles))) {\n    return false;\n  }\n  if (!('signatures' in response && Array.isArray(response.signatures))) {\n    return false;\n  }\n  return response.signatures.every(s => typeof s === 'string') && response.handles.every(h => typeof h === 'string');\n}\nconst createRelayerEncryptedInput = (aclContractAddress, verifyingContractAddressInputVerification, chainId, gatewayChainId, relayerUrl, tfheCompactPublicKey, publicParams, coprocessorSigners, thresholdCoprocessorSigners, instanceOptions) => (contractAddress, userAddress) => {\n  if (!isAddress(contractAddress)) {\n    throw new Error('Contract address is not a valid address.');\n  }\n  if (!isAddress(userAddress)) {\n    throw new Error('User address is not a valid address.');\n  }\n  const input = createEncryptedInput({\n    aclContractAddress,\n    chainId,\n    tfheCompactPublicKey,\n    publicParams,\n    contractAddress,\n    userAddress\n  });\n  return {\n    _input: input,\n    addBool(value) {\n      input.addBool(value);\n      return this;\n    },\n    add8(value) {\n      input.add8(value);\n      return this;\n    },\n    add16(value) {\n      input.add16(value);\n      return this;\n    },\n    add32(value) {\n      input.add32(value);\n      return this;\n    },\n    add64(value) {\n      input.add64(value);\n      return this;\n    },\n    add128(value) {\n      input.add128(value);\n      return this;\n    },\n    add256(value) {\n      input.add256(value);\n      return this;\n    },\n    addAddress(value) {\n      input.addAddress(value);\n      return this;\n    },\n    getBits() {\n      return input.getBits();\n    },\n    encrypt: function () {\n      var _ref10 = _asyncToGenerator(function* (options) {\n        const extraData = '0x00';\n        const bits = input.getBits();\n        const ciphertext = input.encrypt();\n        const payload = {\n          contractAddress: getAddress(contractAddress),\n          userAddress: getAddress(userAddress),\n          ciphertextWithInputVerification: toHexString(ciphertext),\n          contractChainId: '0x' + chainId.toString(16),\n          extraData\n        };\n        const json = yield fetchRelayerJsonRpcPost('INPUT_PROOF', `${relayerUrl}/v1/input-proof`, payload, options ?? instanceOptions);\n        if (!isFhevmRelayerInputProofResponse(json)) {\n          throwRelayerInternalError('INPUT_PROOF', json);\n        }\n        const handles = computeHandles(ciphertext, bits, aclContractAddress, chainId, currentCiphertextVersion());\n        // Note that the hex strings returned by the relayer do have have the 0x prefix\n        if (json.response.handles && json.response.handles.length > 0) {\n          const responseHandles = json.response.handles.map(fromHexString);\n          if (handles.length != responseHandles.length) {\n            throw new Error(`Incorrect Handles list sizes: (expected) ${handles.length} != ${responseHandles.length} (received)`);\n          }\n          for (let index = 0; index < handles.length; index += 1) {\n            let handle = handles[index];\n            let responseHandle = responseHandles[index];\n            let expected = toHexString(handle);\n            let current = toHexString(responseHandle);\n            if (expected !== current) {\n              throw new Error(`Incorrect Handle ${index}: (expected) ${expected} != ${current} (received)`);\n            }\n          }\n        }\n        const signatures = json.response.signatures;\n        // verify signatures for inputs:\n        const domain = {\n          name: 'InputVerification',\n          version: '1',\n          chainId: gatewayChainId,\n          verifyingContract: verifyingContractAddressInputVerification\n        };\n        const types = {\n          CiphertextVerification: [{\n            name: 'ctHandles',\n            type: 'bytes32[]'\n          }, {\n            name: 'userAddress',\n            type: 'address'\n          }, {\n            name: 'contractAddress',\n            type: 'address'\n          }, {\n            name: 'contractChainId',\n            type: 'uint256'\n          }, {\n            name: 'extraData',\n            type: 'bytes'\n          }]\n        };\n        const recoveredAddresses = signatures.map(signature => {\n          const sig = signature.startsWith('0x') ? signature : `0x${signature}`;\n          const recoveredAddress = ethers.verifyTypedData(domain, types, {\n            ctHandles: handles,\n            userAddress,\n            contractAddress,\n            contractChainId: chainId,\n            extraData\n          }, sig);\n          return recoveredAddress;\n        });\n        const thresholdReached = isThresholdReached$1(coprocessorSigners, recoveredAddresses, thresholdCoprocessorSigners);\n        if (!thresholdReached) {\n          throw Error('Coprocessor signers threshold is not reached');\n        }\n        // inputProof is len(list_handles) + numCoprocessorSigners + list_handles + signatureCoprocessorSigners (1+1+NUM_HANDLES*32+65*numSigners)\n        let inputProof = numberToHex(handles.length);\n        const numSigners = signatures.length;\n        inputProof += numberToHex(numSigners);\n        const listHandlesStr = handles.map(i => toHexString(i));\n        listHandlesStr.map(handle => inputProof += handle);\n        signatures.map(signature => inputProof += signature.slice(2)); // removes the '0x' prefix from the `signature` string\n        // Append the extra data to the input proof\n        inputProof += extraData.slice(2);\n        return {\n          handles,\n          inputProof: fromHexString(inputProof)\n        };\n      });\n      return function encrypt(_x42) {\n        return _ref10.apply(this, arguments);\n      };\n    }()\n  };\n};\nconst aclABI = ['function isAllowedForDecryption(bytes32 handle) view returns (bool)'];\nfunction isThresholdReached(kmsSigners, recoveredAddresses, threshold) {\n  const addressMap = new Map();\n  recoveredAddresses.forEach((address, index) => {\n    if (addressMap.has(address)) {\n      const duplicateValue = address;\n      throw new Error(`Duplicate KMS signer address found: ${duplicateValue} appears multiple times in recovered addresses`);\n    }\n    addressMap.set(address, index);\n  });\n  for (const address of recoveredAddresses) {\n    if (!kmsSigners.includes(address)) {\n      throw new Error(`Invalid address found: ${address} is not in the list of KMS signers`);\n    }\n  }\n  return recoveredAddresses.length >= threshold;\n}\nconst CiphertextType = {\n  0: 'bool',\n  2: 'uint256',\n  3: 'uint256',\n  4: 'uint256',\n  5: 'uint256',\n  6: 'uint256',\n  7: 'address',\n  8: 'uint256'\n};\nfunction deserializeDecryptedResult(handles, decryptedResult) {\n  let typesList = [];\n  for (const handle of handles) {\n    const hexPair = handle.slice(-4, -2).toLowerCase();\n    const typeDiscriminant = parseInt(hexPair, 16);\n    typesList.push(typeDiscriminant);\n  }\n  const restoredEncoded = '0x' + '00'.repeat(32) +\n  // dummy requestID (ignored)\n  decryptedResult.slice(2) + '00'.repeat(32); // dummy empty bytes[] length (ignored)\n  const abiTypes = typesList.map(t => {\n    const abiType = CiphertextType[t]; // all types are valid because this was supposedly checked already inside the `checkEncryptedBits` function\n    return abiType;\n  });\n  const coder = new AbiCoder();\n  const decoded = coder.decode(['uint256', ...abiTypes, 'bytes[]'], restoredEncoded);\n  // strip dummy first/last element\n  const rawValues = decoded.slice(1, 1 + typesList.length);\n  let results = {};\n  handles.forEach((handle, idx) => results[handle] = rawValues[idx]);\n  return results;\n}\nconst publicDecryptRequest = (kmsSigners, thresholdSigners, gatewayChainId, verifyingContractAddress, aclContractAddress, relayerUrl, provider, instanceOptions) => (/*#__PURE__*/function () {\n  var _ref11 = _asyncToGenerator(function* (_handles, options) {\n    const extraData = '0x00';\n    const acl = new ethers.Contract(aclContractAddress, aclABI, provider);\n    let handles;\n    try {\n      handles = yield Promise.all(_handles.map(/*#__PURE__*/function () {\n        var _ref12 = _asyncToGenerator(function* (_handle) {\n          const handle = typeof _handle === 'string' ? toHexString(fromHexString(_handle), true) : toHexString(_handle, true);\n          const isAllowedForDecryption = yield acl.isAllowedForDecryption(handle);\n          if (!isAllowedForDecryption) {\n            throw new Error(`Handle ${handle} is not allowed for public decryption!`);\n          }\n          return handle;\n        });\n        return function (_x45) {\n          return _ref12.apply(this, arguments);\n        };\n      }()));\n    } catch (e) {\n      throw e;\n    }\n    // check 2048 bits limit\n    checkEncryptedBits(handles);\n    const payloadForRequest = {\n      ciphertextHandles: handles,\n      extraData\n    };\n    const json = yield fetchRelayerJsonRpcPost('PUBLIC_DECRYPT', `${relayerUrl}/v1/public-decrypt`, payloadForRequest, options ?? instanceOptions);\n    // verify signatures on decryption:\n    const domain = {\n      name: 'Decryption',\n      version: '1',\n      chainId: gatewayChainId,\n      verifyingContract: verifyingContractAddress\n    };\n    const types = {\n      PublicDecryptVerification: [{\n        name: 'ctHandles',\n        type: 'bytes32[]'\n      }, {\n        name: 'decryptedResult',\n        type: 'bytes'\n      }, {\n        name: 'extraData',\n        type: 'bytes'\n      }]\n    };\n    const result = json.response[0];\n    const decryptedResult = result.decrypted_value.startsWith('0x') ? result.decrypted_value : `0x${result.decrypted_value}`;\n    const signatures = result.signatures;\n    const signedExtraData = '0x';\n    const recoveredAddresses = signatures.map(signature => {\n      const sig = signature.startsWith('0x') ? signature : `0x${signature}`;\n      const recoveredAddress = ethers.verifyTypedData(domain, types, {\n        ctHandles: handles,\n        decryptedResult,\n        extraData: signedExtraData\n      }, sig);\n      return recoveredAddress;\n    });\n    const thresholdReached = isThresholdReached(kmsSigners, recoveredAddresses, thresholdSigners);\n    if (!thresholdReached) {\n      throw Error('KMS signers threshold is not reached');\n    }\n    const results = deserializeDecryptedResult(handles, decryptedResult);\n    return results;\n  });\n  return function (_x43, _x44) {\n    return _ref11.apply(this, arguments);\n  };\n}());\n\n/**\n * Creates an EIP712 structure specifically for user decrypt requests\n *\n * @param gatewayChainId - The chain ID of the gateway\n * @param verifyingContract - The address of the contract that will verify the signature\n * @param publicKey - The user's public key as a hex string or Uint8Array\n * @param contractAddresses - Array of contract addresses that can access the decryption\n * @param contractsChainId - The chain ID where the contracts are deployed\n * @param startTimestamp - The timestamp when the decryption permission becomes valid\n * @param durationDays - How many days the decryption permission remains valid\n * @param delegatedAccount - Optional delegated account address\n * @returns EIP712 typed data structure for user decryption\n */\nconst createEIP712 = (verifyingContract, contractsChainId) => (publicKey, contractAddresses, startTimestamp, durationDays, delegatedAccount) => {\n  const extraData = '0x00';\n  if (delegatedAccount && !isAddress(delegatedAccount)) throw new Error('Invalid delegated account.');\n  if (!isAddress(verifyingContract)) {\n    throw new Error('Invalid verifying contract address.');\n  }\n  if (!contractAddresses.every(c => isAddress(c))) {\n    throw new Error('Invalid contract address.');\n  }\n  // Format the public key based on its type\n  const formattedPublicKey = typeof publicKey === 'string' ? publicKey.startsWith('0x') ? publicKey : `0x${publicKey}` : publicKey;\n  // Convert timestamps to strings if they're bigints\n  const formattedStartTimestamp = typeof startTimestamp === 'number' ? startTimestamp.toString() : startTimestamp;\n  const formattedDurationDays = typeof durationDays === 'number' ? durationDays.toString() : durationDays;\n  const EIP712Domain = [{\n    name: 'name',\n    type: 'string'\n  }, {\n    name: 'version',\n    type: 'string'\n  }, {\n    name: 'chainId',\n    type: 'uint256'\n  }, {\n    name: 'verifyingContract',\n    type: 'address'\n  }];\n  const domain = {\n    name: 'Decryption',\n    version: '1',\n    chainId: contractsChainId,\n    verifyingContract\n  };\n  if (delegatedAccount) {\n    return {\n      types: {\n        EIP712Domain,\n        DelegatedUserDecryptRequestVerification: [{\n          name: 'publicKey',\n          type: 'bytes'\n        }, {\n          name: 'contractAddresses',\n          type: 'address[]'\n        }, {\n          name: 'contractsChainId',\n          type: 'uint256'\n        }, {\n          name: 'startTimestamp',\n          type: 'uint256'\n        }, {\n          name: 'durationDays',\n          type: 'uint256'\n        }, {\n          name: 'extraData',\n          type: 'bytes'\n        }, {\n          name: 'delegatedAccount',\n          type: 'address'\n        }]\n      },\n      primaryType: 'DelegatedUserDecryptRequestVerification',\n      domain,\n      message: {\n        publicKey: formattedPublicKey,\n        contractAddresses,\n        contractsChainId,\n        startTimestamp: formattedStartTimestamp,\n        durationDays: formattedDurationDays,\n        extraData,\n        delegatedAccount: delegatedAccount\n      }\n    };\n  }\n  return {\n    types: {\n      EIP712Domain,\n      UserDecryptRequestVerification: [{\n        name: 'publicKey',\n        type: 'bytes'\n      }, {\n        name: 'contractAddresses',\n        type: 'address[]'\n      }, {\n        name: 'contractsChainId',\n        type: 'uint256'\n      }, {\n        name: 'startTimestamp',\n        type: 'uint256'\n      }, {\n        name: 'durationDays',\n        type: 'uint256'\n      }, {\n        name: 'extraData',\n        type: 'bytes'\n      }]\n    },\n    primaryType: 'UserDecryptRequestVerification',\n    domain,\n    message: {\n      publicKey: formattedPublicKey,\n      contractAddresses,\n      contractsChainId,\n      startTimestamp: formattedStartTimestamp,\n      durationDays: formattedDurationDays,\n      extraData\n    }\n  };\n};\nconst generateKeypair = () => {\n  const keypair = TKMS.ml_kem_pke_keygen();\n  return {\n    publicKey: toHexString(TKMS.ml_kem_pke_pk_to_u8vec(TKMS.ml_kem_pke_get_pk(keypair))),\n    privateKey: toHexString(TKMS.ml_kem_pke_sk_to_u8vec(keypair))\n  };\n};\nglobal.fetch = fetchRetry(global.fetch, {\n  retries: 5,\n  retryDelay: 500\n});\nconst SepoliaConfig = {\n  // ACL_CONTRACT_ADDRESS (FHEVM Host chain)\n  aclContractAddress: '0x687820221192C5B662b25367F70076A37bc79b6c',\n  // KMS_VERIFIER_CONTRACT_ADDRESS (FHEVM Host chain)\n  kmsContractAddress: '0x1364cBBf2cDF5032C47d8226a6f6FBD2AFCDacAC',\n  // INPUT_VERIFIER_CONTRACT_ADDRESS (FHEVM Host chain)\n  inputVerifierContractAddress: '0xbc91f3daD1A5F19F8390c400196e58073B6a0BC4',\n  // DECRYPTION_ADDRESS (Gateway chain)\n  verifyingContractAddressDecryption: '0xb6E160B1ff80D67Bfe90A85eE06Ce0A2613607D1',\n  // INPUT_VERIFICATION_ADDRESS (Gateway chain)\n  verifyingContractAddressInputVerification: '0x7048C39f048125eDa9d678AEbaDfB22F7900a29F',\n  // FHEVM Host chain id\n  chainId: 11155111,\n  // Gateway chain id\n  gatewayChainId: 55815,\n  // Optional RPC provider to host chain\n  network: 'https://eth-sepolia.public.blastapi.io',\n  // Relayer URL\n  relayerUrl: 'https://relayer.testnet.zama.cloud'\n};\nconst createInstance = /*#__PURE__*/function () {\n  var _ref13 = _asyncToGenerator(function* (config) {\n    const {\n      verifyingContractAddressDecryption,\n      verifyingContractAddressInputVerification,\n      publicKey,\n      kmsContractAddress,\n      aclContractAddress,\n      gatewayChainId,\n      auth\n    } = config;\n    if (!kmsContractAddress || !isAddress(kmsContractAddress)) {\n      throw new Error('KMS contract address is not valid or empty');\n    }\n    if (!verifyingContractAddressDecryption || !isAddress(verifyingContractAddressDecryption)) {\n      throw new Error('Verifying contract for Decryption address is not valid or empty');\n    }\n    if (!verifyingContractAddressInputVerification || !isAddress(verifyingContractAddressInputVerification)) {\n      throw new Error('Verifying contract for InputVerification address is not valid or empty');\n    }\n    if (!aclContractAddress || !isAddress(aclContractAddress)) {\n      throw new Error('ACL contract address is not valid or empty');\n    }\n    if (publicKey && !(publicKey.data instanceof Uint8Array)) throw new Error('publicKey must be a Uint8Array');\n    const provider = getProvider(config);\n    if (!provider) {\n      throw new Error('No network has been provided!');\n    }\n    const chainId = yield getChainId(provider, config);\n    const publicKeyData = yield getTfheCompactPublicKey(config);\n    const publicParamsData = yield getPublicParams(config);\n    const kmsSigners = yield getKMSSigners(provider, config);\n    const thresholdKMSSigners = yield getKMSSignersThreshold(provider, config);\n    const coprocessorSigners = yield getCoprocessorSigners(provider, config);\n    const thresholdCoprocessorSigners = yield getCoprocessorSignersThreshold(provider, config);\n    return {\n      createEncryptedInput: createRelayerEncryptedInput(aclContractAddress, verifyingContractAddressInputVerification, chainId, gatewayChainId, cleanURL(config.relayerUrl), publicKeyData.publicKey, publicParamsData, coprocessorSigners, thresholdCoprocessorSigners),\n      generateKeypair,\n      createEIP712: createEIP712(verifyingContractAddressDecryption, chainId),\n      publicDecrypt: publicDecryptRequest(kmsSigners, thresholdKMSSigners, gatewayChainId, verifyingContractAddressDecryption, aclContractAddress, cleanURL(config.relayerUrl), provider, auth && {\n        auth\n      }),\n      userDecrypt: userDecryptRequest(kmsSigners, gatewayChainId, chainId, verifyingContractAddressDecryption, aclContractAddress, cleanURL(config.relayerUrl), provider, auth && {\n        auth\n      }),\n      getPublicKey: () => publicKeyData.publicKey ? {\n        publicKey: publicKeyData.publicKey.safe_serialize(SERIALIZED_SIZE_LIMIT_PK),\n        publicKeyId: publicKeyData.publicKeyId\n      } : null,\n      getPublicParams: bits => {\n        if (publicParamsData[bits]) {\n          return {\n            publicParams: publicParamsData[bits].publicParams.safe_serialize(SERIALIZED_SIZE_LIMIT_CRS),\n            publicParamsId: publicParamsData[bits].publicParamsId\n          };\n        }\n        return null;\n      }\n    };\n  });\n  return function createInstance(_x46) {\n    return _ref13.apply(this, arguments);\n  };\n}();\nlet initialized = false;\nconst initSDK = /*#__PURE__*/function () {\n  var _ref14 = _asyncToGenerator(function* ({\n    tfheParams,\n    kmsParams,\n    thread\n  } = {}) {\n    if (thread == null) thread = navigator.hardwareConcurrency;\n    let supportsThreads = yield threads();\n    if (!supportsThreads) {\n      console.warn('This browser does not support threads. Verify that your server returns correct headers:\\n', \"'Cross-Origin-Opener-Policy': 'same-origin'\\n\", \"'Cross-Origin-Embedder-Policy': 'require-corp'\");\n      thread = undefined;\n    }\n    if (!initialized) {\n      yield __wbg_init$1({\n        module_or_path: tfheParams\n      });\n      yield __wbg_init({\n        module_or_path: kmsParams\n      });\n      if (thread) {\n        init_panic_hook();\n        yield initThreadPool(thread);\n      }\n      initialized = true;\n    }\n    return true;\n  });\n  return function initSDK() {\n    return _ref14.apply(this, arguments);\n  };\n}();\n\n// ESM explicit named re-export is required.\nwindow.TFHE = {\n  default: __wbg_init$1,\n  initThreadPool,\n  init_panic_hook,\n  TfheCompactPublicKey: TfheCompactPublicKey,\n  CompactPkeCrs: CompactPkeCrs,\n  CompactCiphertextList: CompactCiphertextList,\n  ZkComputeLoad: ZkComputeLoad\n};\nwindow.TKMS = {\n  default: __wbg_init,\n  u8vec_to_ml_kem_pke_pk,\n  u8vec_to_ml_kem_pke_sk,\n  new_client,\n  new_server_id_addr,\n  process_user_decryption_resp_from_js,\n  ml_kem_pke_keygen,\n  ml_kem_pke_pk_to_u8vec,\n  ml_kem_pke_sk_to_u8vec,\n  ml_kem_pke_get_pk\n};\nexport { ENCRYPTION_TYPES, SepoliaConfig, createEIP712, createInstance, generateKeypair, getErrorCauseCode, getErrorCauseStatus, initSDK };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}