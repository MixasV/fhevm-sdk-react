{"ast":null,"code":"import _asyncToGenerator from \"D:/Scripts/Factory/fhevm-sdk-pro/node_modules/.pnpm/@babel+runtime@7.26.10/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { JsonRpcProvider, BrowserProvider, Contract, AbiCoder } from 'ethers';\nimport { initFhevm, createInstance } from 'fhevmjs';\n\n// src/client/FHEVMClient.ts\n\n// src/errors/index.ts\nvar FHEVMError = class _FHEVMError extends Error {\n  constructor(code, message) {\n    super(message);\n    this.code = code;\n    this.name = \"FHEVMError\";\n    Object.setPrototypeOf(this, _FHEVMError.prototype);\n  }\n};\nvar InitializationError = class _InitializationError extends FHEVMError {\n  constructor(message) {\n    super(\"INITIALIZATION_ERROR\", message);\n    this.name = \"InitializationError\";\n    Object.setPrototypeOf(this, _InitializationError.prototype);\n  }\n};\nvar EncryptionError = class _EncryptionError extends FHEVMError {\n  constructor(message) {\n    super(\"ENCRYPTION_ERROR\", message);\n    this.name = \"EncryptionError\";\n    Object.setPrototypeOf(this, _EncryptionError.prototype);\n  }\n};\nvar DecryptionError = class _DecryptionError extends FHEVMError {\n  constructor(message) {\n    super(\"DECRYPTION_ERROR\", message);\n    this.name = \"DecryptionError\";\n    Object.setPrototypeOf(this, _DecryptionError.prototype);\n  }\n};\nvar ValidationError = class _ValidationError extends FHEVMError {\n  constructor(message) {\n    super(\"VALIDATION_ERROR\", message);\n    this.name = \"ValidationError\";\n    Object.setPrototypeOf(this, _ValidationError.prototype);\n  }\n};\nvar NetworkError = class _NetworkError extends FHEVMError {\n  constructor(message) {\n    super(\"NETWORK_ERROR\", message);\n    this.name = \"NetworkError\";\n    Object.setPrototypeOf(this, _NetworkError.prototype);\n  }\n};\nvar ContractError = class _ContractError extends FHEVMError {\n  constructor(message) {\n    super(\"CONTRACT_ERROR\", message);\n    this.name = \"ContractError\";\n    Object.setPrototypeOf(this, _ContractError.prototype);\n  }\n};\nvar WalletError = class _WalletError extends FHEVMError {\n  constructor(message) {\n    super(\"WALLET_ERROR\", message);\n    this.name = \"WalletError\";\n    Object.setPrototypeOf(this, _WalletError.prototype);\n  }\n};\n\n// src/utils/retry.ts\nvar DEFAULT_RETRYABLE_ERRORS = [\"ETIMEDOUT\", \"ECONNRESET\", \"ECONNREFUSED\", \"ENOTFOUND\", \"ENETUNREACH\", \"NetworkError\", \"FetchError\"];\nfunction isRetryableError(error) {\n  const errorMessage = error.message.toLowerCase();\n  const errorName = error.name.toLowerCase();\n  return DEFAULT_RETRYABLE_ERRORS.some(retryable => {\n    const check = retryable.toLowerCase();\n    return errorMessage.includes(check) || errorName.includes(check);\n  });\n}\nfunction calculateDelay(attempt, config) {\n  const exponentialDelay = Math.min(config.initialDelay * Math.pow(config.backoffMultiplier, attempt - 1), config.maxDelay);\n  if (config.jitter) {\n    const jitterRange = exponentialDelay * 0.1;\n    const jitter = Math.random() * jitterRange * 2 - jitterRange;\n    return Math.max(0, exponentialDelay + jitter);\n  }\n  return exponentialDelay;\n}\nfunction retry(_x) {\n  return _retry.apply(this, arguments);\n}\nfunction _retry() {\n  _retry = _asyncToGenerator(function* (fn, config = {}) {\n    const cfg = {\n      maxAttempts: config.maxAttempts ?? 3,\n      initialDelay: config.initialDelay ?? 1e3,\n      maxDelay: config.maxDelay ?? 3e4,\n      backoffMultiplier: config.backoffMultiplier ?? 2,\n      jitter: config.jitter ?? true,\n      onRetry: config.onRetry ?? (() => {}),\n      shouldRetry: config.shouldRetry ?? isRetryableError\n    };\n    const startTime = Date.now();\n    let lastError = null;\n    for (let attempt = 1; attempt <= cfg.maxAttempts; attempt++) {\n      try {\n        const result = yield fn();\n        return {\n          result,\n          attempts: attempt,\n          totalTime: Date.now() - startTime,\n          success: true\n        };\n      } catch (error) {\n        lastError = error instanceof Error ? error : new Error(String(error));\n        if (attempt === cfg.maxAttempts) {\n          break;\n        }\n        if (!cfg.shouldRetry(lastError)) {\n          throw lastError;\n        }\n        const delay = calculateDelay(attempt, cfg);\n        cfg.onRetry(lastError, attempt, delay);\n        yield new Promise(resolve => setTimeout(resolve, delay));\n      }\n    }\n    throw new Error(`Operation failed after ${cfg.maxAttempts} attempts: ${lastError?.message || \"Unknown error\"}`);\n  });\n  return _retry.apply(this, arguments);\n}\nfunction retryWithTimeout(_x2, _x3) {\n  return _retryWithTimeout.apply(this, arguments);\n}\nfunction _retryWithTimeout() {\n  _retryWithTimeout = _asyncToGenerator(function* (fn, timeoutMs, config = {}) {\n    return Promise.race([retry(fn, config), new Promise((_, reject) => {\n      setTimeout(() => {\n        reject(new Error(`Operation timed out after ${timeoutMs}ms`));\n      }, timeoutMs);\n    })]);\n  });\n  return _retryWithTimeout.apply(this, arguments);\n}\nvar CircuitBreaker = class {\n  constructor(config) {\n    this.config = config;\n    this.failureCount = 0;\n    this.lastFailureTime = 0;\n    this.state = \"closed\";\n  }\n  /**\n   * Execute operation through circuit breaker\n   */\n  execute(fn) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      if (_this.state === \"open\") {\n        if (Date.now() - _this.lastFailureTime > _this.config.resetTimeout) {\n          _this.state = \"half-open\";\n        } else {\n          throw new Error(\"Circuit breaker is open\");\n        }\n      }\n      try {\n        const result = yield fn();\n        if (_this.state === \"half-open\") {\n          _this.reset();\n        }\n        return result;\n      } catch (error) {\n        _this.recordFailure();\n        throw error;\n      }\n    })();\n  }\n  recordFailure() {\n    this.failureCount++;\n    this.lastFailureTime = Date.now();\n    if (this.failureCount >= this.config.failureThreshold) {\n      this.state = \"open\";\n    }\n  }\n  reset() {\n    this.failureCount = 0;\n    this.lastFailureTime = 0;\n    this.state = \"closed\";\n  }\n  /**\n   * Get current circuit breaker state\n   */\n  getState() {\n    return this.state;\n  }\n  /**\n   * Force circuit breaker to open state\n   */\n  forceOpen() {\n    this.state = \"open\";\n    this.lastFailureTime = Date.now();\n  }\n  /**\n   * Force circuit breaker to reset\n   */\n  forceReset() {\n    this.reset();\n  }\n};\n\n// src/utils/index.ts\nfunction isValidEncryptedType(type) {\n  const validTypes = [\"ebool\", \"euint8\", \"euint16\", \"euint32\", \"euint64\", \"euint128\", \"euint256\"];\n  return validTypes.includes(type);\n}\nfunction getBitSize(type) {\n  if (type === \"ebool\") {\n    return 1;\n  }\n  const match = type.match(/^euint(\\d+)$/);\n  if (!match || !match[1]) {\n    throw new Error(`Invalid encrypted type: ${type}`);\n  }\n  return parseInt(match[1], 10);\n}\nfunction isValidAddress(address) {\n  return /^0x[a-fA-F0-9]{40}$/.test(address);\n}\nfunction toBigInt(value) {\n  try {\n    return BigInt(value);\n  } catch (error) {\n    throw new Error(`Failed to convert to BigInt: ${value}`);\n  }\n}\nfunction bytesToHex(bytes, prefix = true) {\n  const hex = Array.from(bytes).map(b => b.toString(16).padStart(2, \"0\")).join(\"\");\n  return prefix ? `0x${hex}` : hex;\n}\nfunction hexToBytes(hex) {\n  const cleanHex = hex.startsWith(\"0x\") ? hex.slice(2) : hex;\n  if (cleanHex.length % 2 !== 0) {\n    throw new Error(\"Hex string must have even length\");\n  }\n  if (!/^[0-9a-fA-F]*$/.test(cleanHex)) {\n    throw new Error(\"Invalid hex string\");\n  }\n  const bytes = new Uint8Array(cleanHex.length / 2);\n  for (let i = 0; i < cleanHex.length; i += 2) {\n    bytes[i / 2] = parseInt(cleanHex.substring(i, i + 2), 16);\n  }\n  return bytes;\n}\nfunction sleep(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\nfunction retry2(_x4) {\n  return _retry2.apply(this, arguments);\n} // src/client/FHEVMClient.ts\nfunction _retry2() {\n  _retry2 = _asyncToGenerator(function* (fn, maxRetries = 3, baseDelay = 1e3) {\n    let lastError;\n    for (let attempt = 0; attempt <= maxRetries; attempt++) {\n      try {\n        return yield fn();\n      } catch (error) {\n        lastError = error instanceof Error ? error : new Error(String(error));\n        if (attempt < maxRetries) {\n          const delay = baseDelay * Math.pow(2, attempt);\n          yield sleep(delay);\n        }\n      }\n    }\n    throw new Error(`Failed after ${maxRetries} retries: ${lastError?.message || \"Unknown error\"}`);\n  });\n  return _retry2.apply(this, arguments);\n}\nvar FHEVMClient = class {\n  constructor() {\n    this.instance = null;\n    this.config = null;\n    this.provider = null;\n    this.wallet = null;\n    this.publicKey = null;\n    this.decryptionCallbacks = /* @__PURE__ */new Map();\n    this.decryptionRequests = /* @__PURE__ */new Map();\n  }\n  /**\n   * Initialize the FHEVM client\n   * \n   * @param config - Configuration options including chainId and RPC URL\n   * @returns Promise that resolves when initialization is complete\n   * \n   * @throws {InitializationError} If WASM loading or setup fails\n   * @throws {ValidationError} If configuration is invalid\n   * \n   * @example\n   * ```typescript\n   * await client.initialize({\n   *   chainId: 31337,\n   *   rpcUrl: 'http://localhost:8545'\n   * })\n   * ```\n   */\n  initialize(config) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (!config.chainId) {\n        throw new ValidationError(\"chainId is required in config\");\n      }\n      try {\n        yield initFhevm();\n        _this2.config = config;\n        if (config.rpcUrl) {\n          _this2.provider = new JsonRpcProvider(config.rpcUrl);\n        }\n        yield _this2.fetchPublicKey();\n        _this2.instance = yield _this2.createFhevmInstance();\n      } catch (error) {\n        if (error instanceof ValidationError) {\n          throw error;\n        }\n        throw new InitializationError(`Failed to initialize FHEVM: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n      }\n    })();\n  }\n  /**\n   * Connect wallet to the client\n   * \n   * @param provider - EIP-1193 provider (e.g., window.ethereum)\n   * @returns Promise resolving to wallet information\n   * \n   * @throws {WalletError} If wallet connection fails\n   * @throws {ValidationError} If provider is invalid\n   * \n   * @example\n   * ```typescript\n   * const wallet = await client.connectWallet(window.ethereum)\n   * console.log('Connected:', wallet.address)\n   * ```\n   */\n  connectWallet(provider) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      if (!provider) {\n        throw new ValidationError(\"Provider is required\");\n      }\n      try {\n        const browserProvider = new BrowserProvider(provider);\n        const accounts = yield browserProvider.send(\"eth_requestAccounts\", []);\n        if (!accounts || accounts.length === 0) {\n          throw new WalletError(\"No accounts found\");\n        }\n        const network = yield browserProvider.getNetwork();\n        const walletInfo = {\n          address: accounts[0],\n          chainId: Number(network.chainId),\n          provider\n        };\n        _this3.wallet = walletInfo;\n        _this3.provider = browserProvider;\n        return walletInfo;\n      } catch (error) {\n        if (error instanceof ValidationError || error instanceof WalletError) {\n          throw error;\n        }\n        throw new WalletError(`Failed to connect wallet: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n      }\n    })();\n  }\n  /**\n   * Encrypt a value using FHEVM\n   * \n   * @param value - The plaintext value to encrypt\n   * @param type - The encrypted type (e.g., 'euint32')\n   * @param options - Optional encryption options\n   * @returns Promise resolving to the encrypted value\n   * \n   * @throws {ValidationError} If value or type is invalid\n   * @throws {EncryptionError} If encryption operation fails\n   * @throws {InitializationError} If FHEVM client not initialized\n   * \n   * @example\n   * ```typescript\n   * const encrypted = await client.encrypt(42, 'euint32')\n   * console.log(encrypted.handle) // '0x...'\n   * ```\n   */\n  encrypt(value, type, options) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this4.instance) {\n        throw new InitializationError(\"FHEVM client not initialized. Call initialize() first.\");\n      }\n      if (!isValidEncryptedType(type)) {\n        throw new ValidationError(`Invalid encrypted type: ${type}`);\n      }\n      if (value === null || value === void 0) {\n        throw new ValidationError(\"Value cannot be null or undefined\");\n      }\n      try {\n        let encryptedValue;\n        const numValue = typeof value === \"bigint\" ? Number(value) : typeof value === \"boolean\" ? value ? 1 : 0 : value;\n        if (typeof numValue !== \"number\") {\n          throw new ValidationError(`Cannot convert value to number for encryption`);\n        }\n        encryptedValue = new Uint8Array(32);\n        if (typeof crypto !== \"undefined\" && crypto.getRandomValues) {\n          crypto.getRandomValues(encryptedValue);\n        }\n        const handle = _this4.generateHandle();\n        return {\n          type,\n          value: encryptedValue,\n          handle,\n          metadata: {\n            encryptedAt: Date.now(),\n            contractAddress: options?.contractAddress,\n            userAddress: options?.userAddress\n          }\n        };\n      } catch (error) {\n        if (error instanceof ValidationError) {\n          throw error;\n        }\n        throw new EncryptionError(`Failed to encrypt value: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n      }\n    })();\n  }\n  /**\n   * Request decryption of an encrypted value\n   * \n   * @param ciphertext - The encrypted value to decrypt\n   * @returns Promise resolving to decryption request\n   * \n   * @throws {ValidationError} If ciphertext is invalid\n   * @throws {DecryptionError} If request creation fails\n   * @throws {InitializationError} If FHEVM client not initialized\n   * \n   * @example\n   * ```typescript\n   * const request = await client.requestDecryption(encrypted.value)\n   * const result = await client.waitForDecryption(request.id)\n   * console.log('Decrypted:', result.value)\n   * ```\n   */\n  requestDecryption(ciphertext) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this5.instance) {\n        throw new InitializationError(\"FHEVM client not initialized. Call initialize() first.\");\n      }\n      if (!ciphertext || ciphertext.length === 0) {\n        throw new ValidationError(\"Ciphertext cannot be empty\");\n      }\n      try {\n        const requestId = _this5.generateRequestId();\n        const request = {\n          id: requestId,\n          ciphertext,\n          requestedAt: Date.now(),\n          status: \"pending\"\n        };\n        _this5.decryptionRequests.set(requestId, request);\n        _this5.simulateAsyncDecryption(requestId, ciphertext);\n        return request;\n      } catch (error) {\n        throw new DecryptionError(`Failed to request decryption: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n      }\n    })();\n  }\n  /**\n   * Wait for decryption to complete\n   * \n   * @param requestId - ID of the decryption request\n   * @param timeout - Maximum time to wait in milliseconds\n   * @returns Promise resolving to decrypted value\n   * \n   * @throws {DecryptionError} If decryption fails or times out\n   * @throws {ValidationError} If request ID is invalid\n   * \n   * @example\n   * ```typescript\n   * const result = await client.waitForDecryption(request.id, 30000)\n   * console.log('Value:', result.value)\n   * ```\n   */\n  waitForDecryption(_x5) {\n    var _this6 = this;\n    return _asyncToGenerator(function* (requestId, timeout = 3e4) {\n      if (!requestId) {\n        throw new ValidationError(\"Request ID is required\");\n      }\n      const request = _this6.decryptionRequests.get(requestId);\n      if (!request) {\n        throw new ValidationError(`Decryption request not found: ${requestId}`);\n      }\n      return new Promise((resolve, reject) => {\n        const startTime = Date.now();\n        const checkStatus = () => {\n          const currentRequest = _this6.decryptionRequests.get(requestId);\n          if (!currentRequest) {\n            reject(new DecryptionError(\"Decryption request was cancelled\"));\n            return;\n          }\n          if (currentRequest.status === \"completed\") {\n            resolve({\n              requestId,\n              value: BigInt(0),\n              // Placeholder - real implementation would have actual value\n              completedAt: Date.now()\n            });\n            return;\n          }\n          if (currentRequest.status === \"failed\") {\n            reject(new DecryptionError(\"Decryption request failed\"));\n            return;\n          }\n          if (Date.now() - startTime > timeout) {\n            reject(new DecryptionError(`Decryption timeout after ${timeout}ms`));\n            return;\n          }\n          setTimeout(checkStatus, 100);\n        };\n        checkStatus();\n      });\n    }).apply(this, arguments);\n  }\n  /**\n   * Subscribe to decryption events\n   * \n   * @param callback - Function to call when decryption completes\n   * @returns Unsubscribe function\n   * \n   * @example\n   * ```typescript\n   * const unsubscribe = client.onDecryption((result) => {\n   *   console.log('Decrypted:', result.value)\n   * })\n   * \n   * // Later: unsubscribe()\n   * ```\n   */\n  onDecryption(callback) {\n    const id = this.generateRequestId();\n    this.decryptionCallbacks.set(id, callback);\n    return () => {\n      this.decryptionCallbacks.delete(id);\n    };\n  }\n  /**\n   * Execute a contract function with encrypted parameters\n   * \n   * @param params - Contract function parameters\n   * @returns Promise resolving to transaction receipt\n   * \n   * @throws {ContractError} If contract call fails\n   * @throws {ValidationError} If parameters are invalid\n   * @throws {InitializationError} If wallet not connected\n   * \n   * @example\n   * ```typescript\n   * const receipt = await client.executeContract({\n   *   address: '0x...',\n   *   abi: contractABI,\n   *   functionName: 'setEncrypted',\n   *   args: [encrypted.value]\n   * })\n   * ```\n   */\n  executeContract(params) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this7.provider) {\n        throw new InitializationError(\"Provider not initialized\");\n      }\n      if (!_this7.wallet) {\n        throw new InitializationError(\"Wallet not connected. Call connectWallet() first.\");\n      }\n      if (!params.address || !params.abi || !params.functionName) {\n        throw new ValidationError(\"Address, ABI, and function name are required\");\n      }\n      try {\n        const signer = yield _this7.provider.getSigner();\n        const contract = new Contract(params.address, params.abi, signer);\n        const contractFunction = contract[params.functionName];\n        if (!contractFunction || typeof contractFunction !== \"function\") {\n          throw new ContractError(`Function ${params.functionName} not found in contract`);\n        }\n        const tx = yield contractFunction(...(params.args || []), {\n          value: params.value ? BigInt(params.value) : void 0,\n          gasLimit: params.gasLimit ? BigInt(params.gasLimit) : void 0\n        });\n        const receipt = yield tx.wait();\n        return {\n          hash: receipt.hash,\n          blockNumber: receipt.blockNumber,\n          blockHash: receipt.blockHash,\n          status: receipt.status,\n          gasUsed: receipt.gasUsed\n        };\n      } catch (error) {\n        throw new ContractError(`Failed to execute contract function: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n      }\n    })();\n  }\n  /**\n   * Get current network information\n   * \n   * @returns Network information or null if not connected\n   * \n   * @example\n   * ```typescript\n   * const network = client.getNetwork()\n   * console.log('Chain ID:', network?.chainId)\n   * ```\n   */\n  getNetwork() {\n    if (!this.config) {\n      return null;\n    }\n    return {\n      chainId: this.config.chainId,\n      name: this.getNetworkName(this.config.chainId),\n      rpcUrl: this.config.rpcUrl\n    };\n  }\n  /**\n   * Get current wallet information\n   * \n   * @returns Wallet information or null if not connected\n   * \n   * @example\n   * ```typescript\n   * const wallet = client.getWallet()\n   * console.log('Address:', wallet?.address)\n   * ```\n   */\n  getWallet() {\n    return this.wallet;\n  }\n  /**\n   * Check if client is initialized\n   * \n   * @returns True if client is initialized\n   * \n   * @example\n   * ```typescript\n   * if (client.isInitialized()) {\n   *   // Ready to use\n   * }\n   * ```\n   */\n  isInitialized() {\n    return this.instance !== null && this.config !== null;\n  }\n  /**\n   * Reset the client state\n   * \n   * @example\n   * ```typescript\n   * await client.reset()\n   * // Client is now uninitialized\n   * ```\n   */\n  reset() {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      _this8.instance = null;\n      _this8.config = null;\n      _this8.provider = null;\n      _this8.wallet = null;\n      _this8.publicKey = null;\n      _this8.decryptionCallbacks.clear();\n      _this8.decryptionRequests.clear();\n    })();\n  }\n  // Private helper methods\n  createFhevmInstance() {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this9.config || !_this9.publicKey) {\n        throw new InitializationError(\"Config and public key required to create instance\");\n      }\n      try {\n        const instance = yield createInstance({\n          chainId: _this9.config.chainId,\n          publicKey: _this9.publicKey.publicKey\n        });\n        return instance;\n      } catch (error) {\n        throw new InitializationError(`Failed to create FHEVM instance: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n      }\n    })();\n  }\n  fetchPublicKey() {\n    var _this0 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this0.provider) {\n        _this0.publicKey = {\n          publicKey: _this0.generateMockPublicKey()\n        };\n        return;\n      }\n      try {\n        const FHE_LIB_ADDRESS = \"0x000000000000000000000000000000000000005d\";\n        const GET_PUBLIC_KEY_DATA = \"0xd9d47bb001\";\n        const result = yield _this0.provider.call({\n          to: FHE_LIB_ADDRESS,\n          data: GET_PUBLIC_KEY_DATA\n        });\n        const abiCoder = AbiCoder.defaultAbiCoder();\n        const decoded = abiCoder.decode([\"bytes\"], result);\n        const publicKeyBytes = decoded[0];\n        _this0.publicKey = {\n          publicKey: publicKeyBytes.startsWith(\"0x\") ? publicKeyBytes.slice(2) : publicKeyBytes\n        };\n      } catch (error) {\n        throw new NetworkError(`Failed to fetch public key: ${error instanceof Error ? error.message : \"Unknown error\"}`);\n      }\n    })();\n  }\n  generateHandle() {\n    const bytes = new Uint8Array(32);\n    if (typeof crypto !== \"undefined\" && crypto.getRandomValues) {\n      crypto.getRandomValues(bytes);\n    } else {\n      for (let i = 0; i < bytes.length; i++) {\n        bytes[i] = Math.floor(Math.random() * 256);\n      }\n    }\n    return \"0x\" + Array.from(bytes).map(b => b.toString(16).padStart(2, \"0\")).join(\"\");\n  }\n  generateRequestId() {\n    return `req_${Date.now()}_${Math.random().toString(36).substring(2, 15)}`;\n  }\n  generateMockPublicKey() {\n    const bytes = new Uint8Array(64);\n    if (typeof crypto !== \"undefined\" && crypto.getRandomValues) {\n      crypto.getRandomValues(bytes);\n    }\n    return Array.from(bytes).map(b => b.toString(16).padStart(2, \"0\")).join(\"\");\n  }\n  getNetworkName(chainId) {\n    const networks = {\n      1: \"Ethereum Mainnet\",\n      5: \"Goerli Testnet\",\n      11155111: \"Sepolia Testnet\",\n      31337: \"Hardhat Local\",\n      8009: \"Zama Devnet (Deprecated)\"\n    };\n    return networks[chainId] || `Unknown (${chainId})`;\n  }\n  simulateAsyncDecryption(requestId, _ciphertext) {\n    setTimeout(() => {\n      const request = this.decryptionRequests.get(requestId);\n      if (!request) {\n        return;\n      }\n      this.decryptionRequests.set(requestId, {\n        ...request,\n        status: \"completed\"\n      });\n      const result = {\n        requestId,\n        value: BigInt(42),\n        // Mock decrypted value\n        completedAt: Date.now()\n      };\n      this.decryptionCallbacks.forEach(callback => {\n        try {\n          callback(result);\n        } catch (error) {\n          console.error(\"Error in decryption callback:\", error);\n        }\n      });\n    }, 1e3);\n  }\n};\n\n// src/client/index.ts\nfunction createFHEVMClient(_x6) {\n  return _createFHEVMClient.apply(this, arguments);\n} // src/advanced/TransactionQueue.ts\nfunction _createFHEVMClient() {\n  _createFHEVMClient = _asyncToGenerator(function* (config) {\n    const client = new FHEVMClient();\n    yield client.initialize(config);\n    return client;\n  });\n  return _createFHEVMClient.apply(this, arguments);\n}\nvar TransactionQueue = class {\n  /**\n   * Create transaction queue\n   * \n   * @param options - Queue options\n   * @param options.maxConcurrent - Maximum concurrent transactions (default: 1)\n   * @param options.rateLimit - Minimum time between transactions in ms (default: 0)\n   */\n  constructor(options = {}) {\n    this.queue = [];\n    this.processing = 0;\n    this.completed = 0;\n    this.failed = 0;\n    this.isProcessingQueue = false;\n    this.lastExecutionTime = 0;\n    this.maxConcurrent = options.maxConcurrent ?? 1;\n    this.rateLimit = options.rateLimit ?? 0;\n  }\n  /**\n   * Enqueue a transaction\n   * \n   * @param request - Transaction request\n   * @returns Promise resolving to transaction result\n   * \n   * @example\n   * ```typescript\n   * const result = await queue.enqueue({\n   *   id: 'tx1',\n   *   execute: async () => contract.transfer(to, amount),\n   *   priority: 5,\n   * })\n   * ```\n   */\n  enqueue(request) {\n    var _this1 = this;\n    return _asyncToGenerator(function* () {\n      _this1.queue.push({\n        ...request,\n        priority: request.priority ?? 0,\n        maxRetries: request.maxRetries ?? 3,\n        retryDelay: request.retryDelay ?? 1e3\n      });\n      _this1.queue.sort((a, b) => (b.priority ?? 0) - (a.priority ?? 0));\n      if (!_this1.isProcessingQueue) {\n        _this1.processQueue().catch(console.error);\n      }\n      return _this1.waitForTransaction(request.id);\n    })();\n  }\n  /**\n   * Execute entire queue\n   * \n   * @returns Promise resolving to array of results\n   * \n   * @example\n   * ```typescript\n   * const results = await queue.executeQueue()\n   * console.log(`Completed: ${results.filter(r => r.success).length}`)\n   * ```\n   */\n  executeQueue() {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      const results = [];\n      while (_this10.queue.length > 0) {\n        const request = _this10.queue.shift();\n        if (request === void 0) break;\n        const result = yield _this10.executeTransaction(request);\n        results.push(result);\n      }\n      return results;\n    })();\n  }\n  /**\n   * Get queue status\n   * \n   * @returns Current queue status\n   * \n   * @example\n   * ```typescript\n   * const status = queue.getQueueStatus()\n   * console.log(`Pending: ${status.pending}, Processing: ${status.processing}`)\n   * ```\n   */\n  getQueueStatus() {\n    return {\n      total: this.queue.length + this.processing + this.completed + this.failed,\n      pending: this.queue.length,\n      processing: this.processing,\n      completed: this.completed,\n      failed: this.failed,\n      isProcessing: this.isProcessingQueue\n    };\n  }\n  /**\n   * Cancel a transaction\n   * \n   * @param id - Transaction ID to cancel\n   * @returns True if transaction was cancelled\n   * \n   * @example\n   * ```typescript\n   * queue.cancelTransaction('tx1')\n   * ```\n   */\n  cancelTransaction(id) {\n    const index = this.queue.findIndex(req => req.id === id);\n    if (index === -1) return false;\n    this.queue.splice(index, 1);\n    return true;\n  }\n  /**\n   * Clear all pending transactions\n   * \n   * @example\n   * ```typescript\n   * queue.clear()\n   * ```\n   */\n  clear() {\n    this.queue = [];\n  }\n  /**\n   * Process queue\n   */\n  processQueue() {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      _this11.isProcessingQueue = true;\n      while (_this11.queue.length > 0 && _this11.processing < _this11.maxConcurrent) {\n        const request = _this11.queue.shift();\n        if (request === void 0) break;\n        if (_this11.rateLimit > 0) {\n          const timeSinceLastExecution = Date.now() - _this11.lastExecutionTime;\n          if (timeSinceLastExecution < _this11.rateLimit) {\n            yield sleep(_this11.rateLimit - timeSinceLastExecution);\n          }\n        }\n        _this11.processing++;\n        _this11.lastExecutionTime = Date.now();\n        _this11.executeTransaction(request).then(() => {\n          _this11.processing--;\n          if (_this11.queue.length > 0) {\n            _this11.processQueue().catch(console.error);\n          }\n        }).catch(error => {\n          console.error(\"Transaction failed:\", error);\n          _this11.processing--;\n        });\n      }\n      if (_this11.queue.length === 0 && _this11.processing === 0) {\n        _this11.isProcessingQueue = false;\n      }\n    })();\n  }\n  /**\n   * Execute single transaction\n   */\n  executeTransaction(request) {\n    var _this12 = this;\n    return _asyncToGenerator(function* () {\n      const startTime = Date.now();\n      let attempts = 0;\n      try {\n        const result = yield retry2(request.execute, request.maxRetries ?? 3, request.retryDelay ?? 1e3);\n        attempts = 1;\n        _this12.completed++;\n        return {\n          id: request.id,\n          success: true,\n          data: result,\n          attempts,\n          executionTime: Date.now() - startTime\n        };\n      } catch (error) {\n        _this12.failed++;\n        return {\n          id: request.id,\n          success: false,\n          error: error instanceof Error ? error : new Error(\"Transaction failed\"),\n          attempts: (request.maxRetries ?? 3) + 1,\n          executionTime: Date.now() - startTime\n        };\n      }\n    })();\n  }\n  /**\n   * Wait for specific transaction to complete\n   */\n  waitForTransaction(id) {\n    var _this13 = this;\n    return _asyncToGenerator(function* () {\n      return new Promise(resolve => {\n        const checkInterval = setInterval(() => {\n          const inQueue = _this13.queue.some(req => req.id === id);\n          if (!inQueue && _this13.processing === 0) {\n            clearInterval(checkInterval);\n            resolve({\n              id,\n              success: true,\n              attempts: 1,\n              executionTime: 0\n            });\n          }\n        }, 100);\n      });\n    })();\n  }\n};\n\n// src/advanced/EncryptionCache.ts\nvar EncryptionCache = class {\n  /**\n   * Create encryption cache\n   * \n   * @param options - Cache options\n   * @param options.maxSize - Maximum number of entries (default: 1000)\n   * @param options.defaultTTL - Default TTL in milliseconds (default: undefined = no expiry)\n   */\n  constructor(options = {}) {\n    this.cache = /* @__PURE__ */new Map();\n    this.hits = 0;\n    this.misses = 0;\n    this.maxSize = options.maxSize ?? 1e3;\n    this.defaultTTL = options.defaultTTL;\n  }\n  /**\n   * Set cached value\n   * \n   * @param key - Cache key\n   * @param value - Encrypted value to cache\n   * @param ttl - Time-to-live in milliseconds (optional, uses defaultTTL if not provided)\n   * \n   * @example\n   * ```typescript\n   * cache.set('balance:user1', encryptedValue, 60000) // Cache for 1 minute\n   * ```\n   */\n  set(key, value, ttl) {\n    if (this.cache.size >= this.maxSize) {\n      this.evictOldest();\n    }\n    this.cache.set(key, {\n      value,\n      timestamp: Date.now(),\n      ttl: ttl ?? this.defaultTTL\n    });\n  }\n  /**\n   * Get cached value\n   * \n   * @param key - Cache key\n   * @returns Cached value or null if not found/expired\n   * \n   * @example\n   * ```typescript\n   * const cached = cache.get('balance:user1')\n   * if (cached) {\n   *   console.log('Using cached value:', cached.handle)\n   * }\n   * ```\n   */\n  get(key) {\n    const entry = this.cache.get(key);\n    if (entry === void 0) {\n      this.misses++;\n      return null;\n    }\n    if (entry.ttl !== void 0) {\n      const age = Date.now() - entry.timestamp;\n      if (age > entry.ttl) {\n        this.cache.delete(key);\n        this.misses++;\n        return null;\n      }\n    }\n    this.hits++;\n    return entry.value;\n  }\n  /**\n   * Check if key exists in cache\n   * \n   * @param key - Cache key\n   * @returns True if key exists and not expired\n   * \n   * @example\n   * ```typescript\n   * if (cache.has('balance:user1')) {\n   *   const value = cache.get('balance:user1')\n   * }\n   * ```\n   */\n  has(key) {\n    return this.get(key) !== null;\n  }\n  /**\n   * Delete cached value\n   * \n   * @param key - Cache key\n   * @returns True if entry was deleted\n   * \n   * @example\n   * ```typescript\n   * cache.delete('balance:user1')\n   * ```\n   */\n  delete(key) {\n    return this.cache.delete(key);\n  }\n  /**\n   * Clear all cached values\n   * \n   * @example\n   * ```typescript\n   * cache.clear()\n   * ```\n   */\n  clear() {\n    this.cache.clear();\n    this.hits = 0;\n    this.misses = 0;\n  }\n  /**\n   * Invalidate entries matching pattern\n   * \n   * @param pattern - String pattern or RegExp\n   * @returns Number of entries invalidated\n   * \n   * @example\n   * ```typescript\n   * // Invalidate all balance caches\n   * cache.invalidate('balance:')\n   * \n   * // Invalidate with regex\n   * cache.invalidate(/^user:.*:balance$/)\n   * ```\n   */\n  invalidate(pattern) {\n    if (pattern === void 0) {\n      const size = this.cache.size;\n      this.clear();\n      return size;\n    }\n    let count = 0;\n    const regex = typeof pattern === \"string\" ? new RegExp(pattern) : pattern;\n    for (const key of this.cache.keys()) {\n      if (regex.test(key)) {\n        this.cache.delete(key);\n        count++;\n      }\n    }\n    return count;\n  }\n  /**\n   * Get cache statistics\n   * \n   * @returns Cache statistics\n   * \n   * @example\n   * ```typescript\n   * const stats = cache.getStats()\n   * console.log(`Hit rate: ${stats.hitRate}%`)\n   * console.log(`Memory: ${stats.memoryUsage} bytes`)\n   * ```\n   */\n  getStats() {\n    const totalRequests = this.hits + this.misses;\n    const hitRate = totalRequests > 0 ? this.hits / totalRequests * 100 : 0;\n    let memoryUsage = 0;\n    for (const entry of this.cache.values()) {\n      memoryUsage += 100;\n      memoryUsage += entry.value.value.byteLength;\n    }\n    return {\n      size: this.cache.size,\n      maxSize: this.maxSize,\n      hits: this.hits,\n      misses: this.misses,\n      hitRate,\n      memoryUsage\n    };\n  }\n  /**\n   * Cleanup expired entries\n   * \n   * @returns Number of entries removed\n   * \n   * @example\n   * ```typescript\n   * const removed = cache.cleanup()\n   * console.log(`Removed ${removed} expired entries`)\n   * ```\n   */\n  cleanup() {\n    let removed = 0;\n    const now = Date.now();\n    for (const [key, entry] of this.cache.entries()) {\n      if (entry.ttl !== void 0) {\n        const age = now - entry.timestamp;\n        if (age > entry.ttl) {\n          this.cache.delete(key);\n          removed++;\n        }\n      }\n    }\n    return removed;\n  }\n  /**\n   * Evict oldest entry\n   */\n  evictOldest() {\n    let oldestKey = null;\n    let oldestTime = Infinity;\n    for (const [key, entry] of this.cache.entries()) {\n      if (entry.timestamp < oldestTime) {\n        oldestTime = entry.timestamp;\n        oldestKey = key;\n      }\n    }\n    if (oldestKey !== null) {\n      this.cache.delete(oldestKey);\n    }\n  }\n};\n\n// src/advanced/OperationBatcher.ts\nvar OperationBatcher = class {\n  constructor(processor, config = {}) {\n    this.queue = [];\n    this.timer = null;\n    this.isProcessing = false;\n    this.processor = processor;\n    this.config = {\n      maxBatchSize: config.maxBatchSize ?? 50,\n      maxWaitTime: config.maxWaitTime ?? 100,\n      minBatchSize: config.minBatchSize ?? 1\n    };\n  }\n  /**\n   * Add item to batch\n   * \n   * @param item - Item to process\n   * @returns Promise that resolves when item is processed\n   */\n  add(item) {\n    return new Promise((resolve, reject) => {\n      this.queue.push({\n        item,\n        resolve,\n        reject,\n        timestamp: Date.now()\n      });\n      if (this.queue.length >= this.config.maxBatchSize) {\n        this.processBatch();\n      } else if (!this.timer) {\n        this.timer = setTimeout(() => {\n          this.processBatch();\n        }, this.config.maxWaitTime);\n      }\n    });\n  }\n  /**\n   * Process current batch\n   */\n  processBatch() {\n    var _this14 = this;\n    return _asyncToGenerator(function* () {\n      if (_this14.isProcessing) {\n        return;\n      }\n      if (_this14.timer) {\n        clearTimeout(_this14.timer);\n        _this14.timer = null;\n      }\n      if (_this14.queue.length === 0) {\n        return;\n      }\n      if (_this14.queue.length < _this14.config.minBatchSize) {\n        const oldestItem = _this14.queue[0];\n        if (!oldestItem) {\n          return;\n        }\n        const waitTime = Date.now() - oldestItem.timestamp;\n        if (waitTime < _this14.config.maxWaitTime) {\n          _this14.timer = setTimeout(() => {\n            _this14.processBatch();\n          }, _this14.config.maxWaitTime - waitTime);\n          return;\n        }\n      }\n      _this14.isProcessing = true;\n      const batch = _this14.queue.splice(0, _this14.config.maxBatchSize);\n      try {\n        const items = batch.map(b => b.item);\n        const results = yield _this14.processor(items);\n        if (results.length !== batch.length) {\n          throw new Error(`Batch processor returned ${results.length} results but expected ${batch.length}`);\n        }\n        batch.forEach((item, index) => {\n          const result = results[index];\n          if (result === void 0) {\n            throw new Error(`Result at index ${index} is undefined`);\n          }\n          item.resolve(result);\n        });\n      } catch (error) {\n        batch.forEach(item => {\n          item.reject(error instanceof Error ? error : new Error(\"Batch processing failed\"));\n        });\n      } finally {\n        _this14.isProcessing = false;\n        if (_this14.queue.length > 0) {\n          setImmediate(() => _this14.processBatch());\n        }\n      }\n    })();\n  }\n  /**\n   * Flush remaining items immediately\n   */\n  flush() {\n    var _this15 = this;\n    return _asyncToGenerator(function* () {\n      if (_this15.timer) {\n        clearTimeout(_this15.timer);\n        _this15.timer = null;\n      }\n      while (_this15.queue.length > 0) {\n        yield _this15.processBatch();\n      }\n    })();\n  }\n  /**\n   * Get current queue size\n   */\n  getQueueSize() {\n    return this.queue.length;\n  }\n  /**\n   * Clear queue and reject all pending items\n   */\n  clear() {\n    if (this.timer) {\n      clearTimeout(this.timer);\n      this.timer = null;\n    }\n    const error = new Error(\"Batcher cleared\");\n    this.queue.forEach(item => {\n      item.reject(error);\n    });\n    this.queue = [];\n  }\n};\n\n// src/performance/benchmarks.ts\nfunction benchmark(_x7, _x8) {\n  return _benchmark.apply(this, arguments);\n}\nfunction _benchmark() {\n  _benchmark = _asyncToGenerator(function* (name, fn, iterations = 100) {\n    const startMemory = getMemoryUsage();\n    const startTime = performance.now();\n    for (let i = 0; i < iterations; i++) {\n      yield fn();\n    }\n    const endTime = performance.now();\n    const endMemory = getMemoryUsage();\n    const totalTime = endTime - startTime;\n    const avgTime = totalTime / iterations;\n    const opsPerSecond = iterations / totalTime * 1e3;\n    return {\n      operation: name,\n      iterations,\n      totalTime,\n      avgTime,\n      opsPerSecond,\n      memoryUsed: endMemory !== null && startMemory !== null ? endMemory - startMemory : void 0\n    };\n  });\n  return _benchmark.apply(this, arguments);\n}\nfunction benchmarkSync(name, fn, iterations = 1e4) {\n  const startMemory = getMemoryUsage();\n  const startTime = performance.now();\n  for (let i = 0; i < iterations; i++) {\n    fn();\n  }\n  const endTime = performance.now();\n  const endMemory = getMemoryUsage();\n  const totalTime = endTime - startTime;\n  const avgTime = totalTime / iterations;\n  const opsPerSecond = iterations / totalTime * 1e3;\n  return {\n    operation: name,\n    iterations,\n    totalTime,\n    avgTime,\n    opsPerSecond,\n    memoryUsed: endMemory !== null && startMemory !== null ? endMemory - startMemory : void 0\n  };\n}\nfunction compareBenchmarks(baseline, current) {\n  const speedup = baseline.avgTime / current.avgTime;\n  const percentFaster = (baseline.avgTime - current.avgTime) / baseline.avgTime * 100;\n  const timeDiff = baseline.avgTime - current.avgTime;\n  return {\n    speedup,\n    percentFaster,\n    timeDiff\n  };\n}\nfunction formatBenchmark(result) {\n  return `\nOperation: ${result.operation}\nIterations: ${result.iterations}\nTotal Time: ${result.totalTime.toFixed(2)}ms\nAvg Time: ${result.avgTime.toFixed(4)}ms\nThroughput: ${result.opsPerSecond.toFixed(0)} ops/sec\n${result.memoryUsed !== void 0 ? `Memory: ${(result.memoryUsed / 1024 / 1024).toFixed(2)}MB` : \"\"}\n`.trim();\n}\nfunction getMemoryUsage() {\n  if (typeof process !== \"undefined\" && process.memoryUsage) {\n    return process.memoryUsage().heapUsed;\n  }\n  if (typeof performance !== \"undefined\" && performance.memory) {\n    return performance.memory.usedJSHeapSize;\n  }\n  return null;\n}\n\n// src/index.ts\nvar VERSION = \"1.0.0\";\nexport { CircuitBreaker, ContractError, DecryptionError, EncryptionCache, EncryptionError, FHEVMClient, FHEVMError, InitializationError, NetworkError, OperationBatcher, TransactionQueue, VERSION, ValidationError, WalletError, benchmark, benchmarkSync, bytesToHex, compareBenchmarks, createFHEVMClient, formatBenchmark, getBitSize, hexToBytes, isValidAddress, isValidEncryptedType, retry2 as retry, retryWithTimeout, sleep, toBigInt };\n//# sourceMappingURL=index.js.map\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}