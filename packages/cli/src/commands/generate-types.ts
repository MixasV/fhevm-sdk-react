/**
 * Generate types command - generates TypeScript types from contract ABI
 * 
 * @packageDocumentation
 */

import * as path from 'path'

import chalk from 'chalk'
import * as fs from 'fs-extra'
import ora from 'ora'

interface GenerateTypesOptions {
  output: string
  contractName?: string
}

interface ABIInput {
  name: string
  type: string
  internalType?: string
}

interface ABIFunction {
  name: string
  type: string
  inputs: ABIInput[]
  outputs: ABIInput[]
  stateMutability: string
}

/**
 * Generate TypeScript types from contract ABI
 * 
 * @param abiFile - Path to ABI JSON file
 * @param options - Generation options
 */
export async function generateTypesCommand(
  abiFile: string,
  options: GenerateTypesOptions
): Promise<void> {
  const spinner = ora('Generating types from ABI...').start()

  try {
    // Read ABI file
    const abiPath = path.resolve(process.cwd(), abiFile)
    
    if (!await fs.pathExists(abiPath)) {
      spinner.fail(chalk.red(`ABI file not found: ${abiFile}`))
      process.exit(1)
    }

    const abiContent: unknown = await fs.readJSON(abiPath)
    const abi: ABIFunction[] = Array.isArray(abiContent) ? abiContent as ABIFunction[] : (abiContent as { abi: ABIFunction[] }).abi

    if (abi === null || abi === undefined || abi.length === 0) {
      spinner.fail(chalk.red('Invalid ABI format'))
      process.exit(1)
    }

    // Extract contract name
    const contractName = (options.contractName !== null && options.contractName !== undefined && options.contractName !== '') ?
                        options.contractName :
                        path.basename(abiFile, path.extname(abiFile))

    spinner.text = 'Parsing ABI and generating types...'

    // Generate TypeScript code
    const typeCode = generateTypeScript(abi, contractName)

    // Ensure output directory exists
    const outputPath = path.resolve(process.cwd(), options.output)
    await fs.ensureDir(path.dirname(outputPath))

    // Write generated code
    await fs.writeFile(outputPath, typeCode)

    spinner.succeed(chalk.green(`Types generated successfully!`))
    // eslint-disable-next-line no-console
    console.log(chalk.white(`\nOutput: ${chalk.cyan(options.output)}`))
    // eslint-disable-next-line no-console
    console.log(chalk.white(`Contract: ${chalk.cyan(contractName)}\n`))

  } catch (error) {
    spinner.fail(chalk.red('Failed to generate types'))
    console.error(error)
    process.exit(1)
  }
}

/**
 * Generate TypeScript code from ABI
 */
function generateTypeScript(abi: ABIFunction[], contractName: string): string {
  const functions = abi.filter((item) => item.type === 'function')
  
  let code = `/**
 * Auto-generated types for ${contractName}
 * 
 * DO NOT EDIT MANUALLY
 * Generated by @mixaspro/cli
 */

import type { EncryptedValue, ContractFunctionParams, TransactionReceipt } from '@mixaspro/core'

`

  // Generate function parameter types
  code += `/**
 * Function parameter types
 */\n`

  for (const func of functions) {
    if (func.inputs.length > 0) {
      code += `export interface ${capitalize(func.name)}Params {\n`
      
      for (const input of func.inputs) {
        const tsType = mapSolidityToTS(input.type)
        code += `  ${input.name || `param${func.inputs.indexOf(input)}`}: ${tsType}\n`
      }
      
      code += `}\n\n`
    }
  }

  // Generate function signatures interface
  code += `/**
 * ${contractName} function signatures
 */
export interface ${contractName}Functions {\n`

  for (const func of functions) {
    const paramsType = func.inputs.length > 0 
      ? `${capitalize(func.name)}Params`
      : 'never'
    
    const returnType = func.outputs.length > 0 && func.outputs[0]
      ? mapSolidityToTS(func.outputs[0].type)
      : 'void'

    code += `  ${func.name}: {\n`
    code += `    params: ${paramsType}\n`
    code += `    returns: ${returnType}\n`
    code += `    stateMutability: '${func.stateMutability}'\n`
    code += `  }\n`
  }

  code += `}\n\n`

  // Generate helper functions
  code += `/**
 * Helper functions for ${contractName}
 */\n\n`

  for (const func of functions) {
    const hasParams = func.inputs.length > 0
    const paramsType = hasParams ? `${capitalize(func.name)}Params` : ''
    const paramsArg = hasParams ? `params: ${paramsType}` : ''

    code += `/**
 * Create parameters for ${func.name}
 */
export function create${capitalize(func.name)}Params(
  contractAddress: string,
  abi: any[],${hasParams ? `\n  ${paramsArg}` : ''}
): ContractFunctionParams {
  return {
    address: contractAddress,
    abi,
    functionName: '${func.name}',${hasParams ? `\n    args: [${func.inputs.map(i => `params.${i.name || `param${func.inputs.indexOf(i)}`}`).join(', ')}],` : ''}
  }
}\n\n`
  }

  // Add contract type
  code += `/**
 * ${contractName} contract interface
 */
export interface ${contractName}Contract {
  address: string
  abi: any[]
}\n\n`

  code += `/**
 * Create ${contractName} contract instance
 */
export function create${contractName}Contract(
  address: string,
  abi: any[]
): ${contractName}Contract {
  return { address, abi }
}\n`

  return code
}

/**
 * Map Solidity type to TypeScript type
 */
function mapSolidityToTS(solidityType: string): string {
  // Handle encrypted types
  if (solidityType.startsWith('e')) {
    if (solidityType === 'ebool') return 'EncryptedValue'
    if (solidityType.match(/^euint\d+$/)) return 'EncryptedValue'
  }

  // Handle standard types
  if (solidityType.startsWith('uint') || solidityType.startsWith('int')) {
    return 'bigint'
  }
  
  if (solidityType === 'bool') return 'boolean'
  if (solidityType === 'address') return 'string'
  if (solidityType === 'string') return 'string'
  if (solidityType.startsWith('bytes')) return 'string'
  
  // Arrays
  if (solidityType.endsWith('[]')) {
    const baseType = solidityType.slice(0, -2)
    return `${mapSolidityToTS(baseType)}[]`
  }

  return 'any'
}

/**
 * Capitalize first letter
 */
function capitalize(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1)
}
